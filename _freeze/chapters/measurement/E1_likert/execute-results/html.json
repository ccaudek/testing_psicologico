{
  "hash": "704b9fe5afda7fb9a655275ca6215559",
  "result": {
    "engine": "knitr",
    "markdown": "# ✏ Esercizi\n\n**Prerequisiti**\n\n**Concetti e Competenze Chiave**\n\n**Preparazione del Notebook**\n\n\n\n\n::: {.cell vscode='{\"languageId\":\"r\"}'}\n\n```{.r .cell-code}\nsource(\"../../code/_common.R\")\n```\n:::\n\n\n\n\n## Manipolazione di dati a livello di scala Likert \n\nIn questo tutorial, ripreso da @brown2023psychometrics, esamineremo i dati di un questionario ordinale. In particolare, esamineremo il **Strengths and Difficulties Questionnaire (SDQ)**, ovvero un breve questionario di screening comportamentale progettato per valutare i comportamenti di bambini e adolescenti tra i 3 e i 16 anni. Il SDQ è disponibile in diverse versioni per soddisfare le esigenze di ricercatori, clinici ed educatori. Per maggiori informazioni, è possibile consultare il sito ufficiale [http://www.sdqinfo.org/](http://www.sdqinfo.org/), dove è possibile scaricare il questionario, insieme alle chiavi di scoring e alle norme pubblicate dal distributore del test. \n\nIl questionario include 25 item suddivisi in 5 scale (o dimensioni) che misurano specifici aspetti comportamentali. Ogni scala comprende 5 item:\n\n- **Sintomi Emotivi:** somatizzazione, preoccupazioni, infelicità, attaccamento, paura  \n- **Problemi di Condotta:** capricci, ubbidienza*, litigi, bugie, furti  \n- **Iperattività:** irrequietezza, agitazione, distrazione, riflessione*, attenzione*  \n- **Problemi con i Pari:** solitudine, amicizia*, popolarità*, vittimismo, miglior amico più grande  \n- **Comportamento Prosociale:** considerazione, condivisione, empatia, gentilezza, aiuto agli altri  \n\nOgni item viene valutato dai partecipanti utilizzando le seguenti opzioni di risposta:\n\n- **0 = \"Non vero\"**  \n- **1 = \"Parzialmente vero\"**  \n- **2 = \"Assolutamente vero\"**  \n\nAlcuni item nel SDQ rappresentano comportamenti che devono essere invertiti rispetto alla scala di appartenenza, ossia **item a punteggio invertito**. Questo significa che punteggi alti sulla scala corrispondono a punteggi bassi per questi specifici item. Ad esempio, l'item *\"Di solito faccio ciò che mi viene detto\"* (variabile \"obeys\") è un item a punteggio invertito per la scala \"Problemi di Condotta\". \n\nNel SDQ sono presenti 5 item di questo tipo, contrassegnati con un asterisco (*) nella tabella. Questi item devono essere codificati invertendo i punteggi (ad esempio, da 0 a 2 e viceversa) prima di calcolare il punteggio complessivo della scala.\n\nIn questo studio, i partecipanti sono studenti di prima media (Year 7) provenienti dalla stessa scuola, per un totale di **228 ragazzi**. Si tratta di un campione della comunità scolastica, quindi non ci si aspetta che molti dei partecipanti superino le soglie cliniche indicate dal test. \n\nIl questionario SDQ è stato somministrato due volte:\n\n1. La prima somministrazione è avvenuta all'inizio della scuola secondaria, quando i ragazzi erano nel Year 7.  \n2. La seconda somministrazione è avvenuta un anno dopo, quando i partecipanti erano nel Year 8.  \n\nQuesta progettazione longitudinale consente di analizzare eventuali cambiamenti nei punteggi SDQ durante il passaggio tra il primo e il secondo anno di scuola secondaria.\n\n## Emotional Symptoms scale\n\nIniziamo ad esaminare la scala **Emotional Symptoms**. Questa scala non contiene item reverse. Importiamo i dati in R.\n\n\n\n\n::: {.cell layout-align=\"center\" vscode='{\"languageId\":\"r\"}'}\n\n```{.r .cell-code}\nload(\"../../data/data_sdq/SDQ.RData\")\nglimpse(SDQ)\n#> Rows: 228\n#> Columns: 51\n#> $ Gender   <dbl> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, …\n#> $ consid   <dbl> 1, 2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, …\n#> $ restles  <dbl> 2, 0, 0, 0, 1, 0, 2, 1, 2, 0, 1, 1, 0, 1, 0, 2, 0, 1, 1, …\n#> $ somatic  <dbl> 2, 2, 0, 0, 2, 1, 0, 0, 1, 0, 0, 2, 0, 0, 1, 2, 1, 1, 1, …\n#> $ shares   <dbl> 1, 1, 2, 2, 0, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 1, 2, 1, …\n#> $ tantrum  <dbl> 0, 0, 0, 0, 1, 0, 2, 0, 2, 0, 0, 1, 0, 1, 1, 2, 0, 1, 1, …\n#> $ loner    <dbl> 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 1, 0, 0, 0, 1, 0, 0, 2, …\n#> $ obeys    <dbl> 2, 2, 2, 2, 0, 2, 2, 2, 2, 2, 1, 1, 2, 2, 1, 2, 2, 2, 1, …\n#> $ worries  <dbl> 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 2, 0, 1, 2, 0, 1, 1, 2, …\n#> $ caring   <dbl> 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 1, 2, 2, …\n#> $ fidgety  <dbl> 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, …\n#> $ friend   <dbl> 2, 2, 2, 2, 0, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 1, …\n#> $ fights   <dbl> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, …\n#> $ unhappy  <dbl> 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 2, …\n#> $ popular  <dbl> 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 2, 1, 2, 1, …\n#> $ distrac  <dbl> 0, 1, 0, 0, 1, 0, 2, 0, 0, 0, 0, 1, 0, 0, 1, 2, 0, 0, 1, …\n#> $ clingy   <dbl> 1, 1, 0, 1, 1, 1, 2, 0, 0, 0, 0, 1, 0, 2, 2, 1, 2, 0, 2, …\n#> $ kind     <dbl> 1, 2, 2, 2, 1, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 1, 2, 2, …\n#> $ lies     <dbl> 0, 0, 0, 0, 2, 0, 1, 0, 2, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, …\n#> $ bullied  <dbl> 0, 0, 0, 0, 2, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, …\n#> $ helpout  <dbl> 2, 1, 2, 2, 0, 2, 2, 2, 1, 2, 1, 2, 2, 1, 2, 2, 1, 2, 1, …\n#> $ reflect  <dbl> 1, 1, 2, 2, 0, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 1, …\n#> $ steals   <dbl> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, …\n#> $ oldbest  <dbl> 1, 0, 2, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 2, …\n#> $ afraid   <dbl> 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 2, 2, 0, 1, 1, 1, 0, 1, …\n#> $ attends  <dbl> 2, 2, 1, 2, 0, 2, 2, 2, 2, 2, 1, 1, 2, 1, 2, 2, 1, 1, 1, …\n#> $ consid2  <dbl> 1, 2, 2, 2, NA, 2, 2, 2, 2, 2, NA, 1, NA, 2, 2, NA, 1, 2,…\n#> $ restles2 <dbl> 0, 1, 2, 1, NA, 0, 1, 1, 0, 0, NA, 2, NA, 0, 1, NA, 1, 1,…\n#> $ somatic2 <dbl> 0, 1, 1, 0, NA, 0, 0, 0, 0, 0, NA, 2, NA, 0, 1, NA, 0, 1,…\n#> $ shares2  <dbl> 1, 2, 2, 1, NA, 2, 1, 2, 2, 2, NA, 2, NA, 2, 2, NA, 1, 2,…\n#> $ tantrum2 <dbl> 0, 1, 2, 0, NA, 0, 2, 0, 0, 0, NA, 2, NA, 0, 1, NA, 1, 0,…\n#> $ loner2   <dbl> 0, 0, 1, 0, NA, 0, 0, 0, 0, 0, NA, 1, NA, 1, 0, NA, 0, 0,…\n#> $ obeys2   <dbl> 2, 1, 2, 1, NA, 2, 2, 2, 2, 1, NA, 1, NA, 2, 1, NA, 1, 2,…\n#> $ worries2 <dbl> 0, 0, 1, 0, NA, NA, 1, 0, 0, 0, NA, 1, NA, 1, 2, NA, 0, 0…\n#> $ caring2  <dbl> 2, 2, 1, 2, NA, 2, 2, 2, 2, 2, NA, 2, NA, 2, 2, NA, 1, 2,…\n#> $ fidgety2 <dbl> 0, 1, 0, 0, NA, 0, 1, 0, 0, 0, NA, 2, NA, 0, 0, NA, 1, 0,…\n#> $ friend2  <dbl> 2, 2, 1, 2, NA, 2, 2, 2, 2, 2, NA, 2, NA, 1, 2, NA, 2, 2,…\n#> $ fights2  <dbl> 0, 0, 0, 0, NA, 0, 0, 0, 0, 0, NA, 2, NA, 0, 0, NA, 0, 0,…\n#> $ unhappy2 <dbl> 0, 0, 1, 0, NA, 0, 0, 0, 0, 0, NA, 1, NA, 0, 0, NA, 0, 0,…\n#> $ popular2 <dbl> 2, 1, 1, 2, NA, 2, 1, 2, 2, 2, NA, 2, NA, 2, 2, NA, 1, 2,…\n#> $ distrac2 <dbl> 0, 0, 0, 2, NA, 0, 2, 1, 0, 0, NA, 1, NA, 0, 1, NA, 1, 0,…\n#> $ clingy2  <dbl> 1, 1, 1, 0, NA, 1, 1, 1, 0, 0, NA, 1, NA, 0, 0, NA, 2, 0,…\n#> $ kind2    <dbl> 2, 2, 2, 2, NA, 2, 2, 2, 2, 2, NA, 2, NA, 2, 2, NA, 1, 2,…\n#> $ lies2    <dbl> 1, 0, 0, 0, NA, 0, 1, 0, 1, 0, NA, 1, NA, 0, 0, NA, 1, 0,…\n#> $ bullied2 <dbl> 0, 0, 0, 0, NA, 0, 2, 0, 0, 0, NA, 0, NA, 0, 0, NA, 0, 0,…\n#> $ helpout2 <dbl> 1, 1, 1, 2, NA, 2, 2, 1, 2, 1, NA, 2, NA, 2, 1, NA, 0, 2,…\n#> $ reflect2 <dbl> 1, 1, 2, 1, NA, 2, 1, 2, 1, 2, NA, 1, NA, 2, 1, NA, 1, 2,…\n#> $ steals2  <dbl> 0, 0, 0, 0, NA, 0, 0, 0, 0, 0, NA, 2, NA, 0, 0, NA, 0, 0,…\n#> $ oldbest2 <dbl> 0, 0, 1, 0, NA, 1, 0, 1, 1, 0, NA, 1, NA, 0, 0, NA, 0, 0,…\n#> $ afraid2  <dbl> 0, 1, 0, 0, NA, 0, 0, 0, 0, 0, NA, 2, NA, 0, 0, NA, 0, 0,…\n#> $ attends2 <dbl> 1, 1, 2, 0, NA, 2, 2, 2, 2, 1, NA, 1, NA, 2, 2, NA, 1, 1,…\n```\n:::\n\n\n\n\nSelezioniamo solo gli item della Emotional Symptoms scale al tempo 1.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nitems_emotion <- c(\"somatic\", \"worries\", \"unhappy\", \"clingy\", \"afraid\")\nsdq_emo <- SDQ[, items_emotion]  \nsdq_emo |>\n    head()\n#> # A tibble: 6 × 5\n#>   somatic worries unhappy clingy afraid\n#>     <dbl>   <dbl>   <dbl>  <dbl>  <dbl>\n#> 1       2       1       0      1      0\n#> 2       2       0       0      1      0\n#> 3       0       0       0      0      1\n#> 4       0       0       0      1      1\n#> 5       2       1       0      1      0\n#> 6       1       0       0      1      0\n```\n:::\n\n\n\n\nCalcoliamo il punteggio della scala.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nrowSums(sdq_emo) \n#>   [1]  4  3  1  2  4  2  4  0  1  1  0  8  2  3  7  4  5  2  8  6  1  4  9\n#>  [24]  4  5  9  0  3  3  1  0  2  6  3  9  4  4  0  7  1  3  6  4  5  4  1\n#>  [47]  4  1  0  5  1  2  2  4  4  4  6  1  8  3  2  2  4  1  1  0  2  2  7\n#>  [70]  5  0 NA NA  1  1  7  4  1  8  3  5  0  5  4  0  1  1  5  3  6  1  3\n#>  [93]  2  6  6  0  2  4  5  3  3  1  1  7  2  3  5  5 NA  0  4  0  4  1  1\n#> [116]  1  1  0  2  7  0  3  8  4  6 NA  2  4  7  1  0  0  1  0  4  3  0 10\n#> [139]  5  2  1  6  1  2  1  0  1 NA  4  4  2  4  7  5  6  1  0  5  3  1  3\n#> [162]  3  6  4  2  3  1  0  3  3  0  3  0  0  0  2  2  2  0  1  5  3  3  1\n#> [185]  4  3  1  6  2  4  2 NA  0  2  5  5  0  2  2  3  4  0  2  4  2  2  1\n#> [208]  3  2  0  1  0  0  8  1  1  2  1  2  2  4  0  0  1  2  2  1  6\n```\n:::\n\n\n\n\nNotiamo che ci sono diversi punteggi mancanti, denotati da NA. Un primo metodo per affrontare i dati mancanti è semplicemente quello di ignorarli:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nrowSums(sdq_emo, na.rm = TRUE) \n#>   [1]  4  3  1  2  4  2  4  0  1  1  0  8  2  3  7  4  5  2  8  6  1  4  9\n#>  [24]  4  5  9  0  3  3  1  0  2  6  3  9  4  4  0  7  1  3  6  4  5  4  1\n#>  [47]  4  1  0  5  1  2  2  4  4  4  6  1  8  3  2  2  4  1  1  0  2  2  7\n#>  [70]  5  0  2  7  1  1  7  4  1  8  3  5  0  5  4  0  1  1  5  3  6  1  3\n#>  [93]  2  6  6  0  2  4  5  3  3  1  1  7  2  3  5  5  4  0  4  0  4  1  1\n#> [116]  1  1  0  2  7  0  3  8  4  6  0  2  4  7  1  0  0  1  0  4  3  0 10\n#> [139]  5  2  1  6  1  2  1  0  1  4  4  4  2  4  7  5  6  1  0  5  3  1  3\n#> [162]  3  6  4  2  3  1  0  3  3  0  3  0  0  0  2  2  2  0  1  5  3  3  1\n#> [185]  4  3  1  6  2  4  2  4  0  2  5  5  0  2  2  3  4  0  2  4  2  2  1\n#> [208]  3  2  0  1  0  0  8  1  1  2  1  2  2  4  0  0  1  2  2  1  6\n```\n:::\n\n\n\n\nTuttavia, questa non è una buona idea. Anche per il fatto che, in questo modo non verrà calcolato il punteggio totale di 7 partecipanti. Possiamo identificare le colonne in cui ci sono dei valori mancanti usando `summary()`.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsummary(sdq_emo)\n#>     somatic         worries         unhappy          clingy     \n#>  Min.   :0.000   Min.   :0.000   Min.   :0.000   Min.   :0.000  \n#>  1st Qu.:0.000   1st Qu.:0.000   1st Qu.:0.000   1st Qu.:0.000  \n#>  Median :0.000   Median :0.000   Median :0.000   Median :1.000  \n#>  Mean   :0.611   Mean   :0.621   Mean   :0.317   Mean   :0.842  \n#>  3rd Qu.:1.000   3rd Qu.:1.000   3rd Qu.:1.000   3rd Qu.:1.000  \n#>  Max.   :2.000   Max.   :2.000   Max.   :2.000   Max.   :2.000  \n#>  NA's   :2       NA's   :1       NA's   :1                      \n#>      afraid    \n#>  Min.   :0.00  \n#>  1st Qu.:0.00  \n#>  Median :0.00  \n#>  Mean   :0.48  \n#>  3rd Qu.:1.00  \n#>  Max.   :2.00  \n#>  NA's   :3\n```\n:::\n\n\n\n\nUn approccio semplice per gestire il problema dei dati mancanti è l'imputazione, che consiste nel sostituire i valori mancanti con stime plausibili basate sulle informazioni disponibili nel dataset. Il metodo più elementare di imputazione prevede la sostituzione del valore mancante con la media della colonna corrispondente. Questo approccio è facile da implementare e può essere utile come soluzione preliminare, ma potrebbe non catturare correttamente la variabilità e le relazioni tra le variabili.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsdq_emo <- sdq_emo %>%\n    mutate_at(vars(somatic:afraid), ~ ifelse(is.na(.), mean(., na.rm = TRUE), .))\n```\n:::\n\n\n\n\nQuesta istruzione utilizza la funzione `mutate_at` del pacchetto dplyr per applicare una trasformazione a colonne specifiche (da `somatic` a `afraid`). All'interno della funzione di trasformazione, essa controlla se ogni valore è mancante (`NA`). Se lo è, lo sostituisce con la media della colonna usando `mean(., na.rm = TRUE)`, che calcola la media escludendo eventuali valori mancanti. \n\nPossiamo ora calcolare il punteggio della scala per ciascun partecipante.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nSDQ$s_emotion <- rowSums(sdq_emo) |> round()\nSDQ$s_emotion \n#>   [1]  4  3  1  2  4  2  4  0  1  1  0  8  2  3  7  4  5  2  8  6  1  4  9\n#>  [24]  4  5  9  0  3  3  1  0  2  6  3  9  4  4  0  7  1  3  6  4  5  4  1\n#>  [47]  4  1  0  5  1  2  2  4  4  4  6  1  8  3  2  2  4  1  1  0  2  2  7\n#>  [70]  5  0  2  8  1  1  7  4  1  8  3  5  0  5  4  0  1  1  5  3  6  1  3\n#>  [93]  2  6  6  0  2  4  5  3  3  1  1  7  2  3  5  5  5  0  4  0  4  1  1\n#> [116]  1  1  0  2  7  0  3  8  4  6  0  2  4  7  1  0  0  1  0  4  3  0 10\n#> [139]  5  2  1  6  1  2  1  0  1  4  4  4  2  4  7  5  6  1  0  5  3  1  3\n#> [162]  3  6  4  2  3  1  0  3  3  0  3  0  0  0  2  2  2  0  1  5  3  3  1\n#> [185]  4  3  1  6  2  4  2  5  0  2  5  5  0  2  2  3  4  0  2  4  2  2  1\n#> [208]  3  2  0  1  0  0  8  1  1  2  1  2  2  4  0  0  1  2  2  1  6\n```\n:::\n\n\n\n\nUn istogramma si ottiene nel modo seguente.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nSDQ |>\n    ggplot(aes(x = s_emotion)) +\n    geom_histogram(bins = 10)\n```\n\n::: {.cell-output-display}\n![](E1_likert_files/figure-html/unnamed-chunk-9-1.png){fig-align='center' width=70%}\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nhist(SDQ$s_emotion)\n```\n\n::: {.cell-output-display}\n![](E1_likert_files/figure-html/unnamed-chunk-10-1.png){fig-align='center' width=70%}\n:::\n:::\n\n\n\n\nPiù utile è un KDE plot.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nSDQ |>\n    ggplot(aes(x = s_emotion)) +\n    geom_density()\n```\n\n::: {.cell-output-display}\n![](E1_likert_files/figure-html/unnamed-chunk-11-1.png){fig-align='center' width=70%}\n:::\n:::\n\n\n\n\nPossiamo ottenere le statistiche descrittive della scala usando la funzione `describe` del pacchetto `psych`.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndescribe(SDQ$s_emotion)\n#>    vars   n mean   sd median trimmed  mad min max range skew kurtosis   se\n#> X1    1 228 2.87 2.31      2    2.65 2.97   0  10    10 0.72    -0.14 0.15\n```\n:::\n\n\n\n\nCome si può vedere, la mediana (il punteggio al di sotto del quale si trova la metà del campione) di `s_emotion` è 2, mentre la media è più alta e pari a 2.87. Questo perché la distribuione dei punteggi è asimmetrica positiva; in questo caso, la mediana è più rappresentativa della tendenza centrale. Queste statistiche sono coerenti con la nostra osservazione dell'istogramma, che mostra un forte *floor effect*.\n\nDi seguito sono riportati i valori di soglia per i casi \"Normali\", \"Borderline\" e \"Anormali\" per i Sintomi Emotivi forniti dal publisher del test (vedi `https://sdqinfo.org/`). Questi sono i punteggi che distinguono i casi probabilmente borderline e anormali dai casi \"normali\".\n\n```\nNormale: 0-5\nBorderline: 6\nAnormale: 7-10\n```\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntable(SDQ$s_emotion <= 5)\n#> \n#> FALSE  TRUE \n#>    32   196\n```\n:::\n\n\n\n\nIn questo campione, dunque, l'85% dei partecipanti è classificato nell'intervallo Normale.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntable(SDQ$s_emotion <= 5)[2] / length(SDQ$s_emotion)\n#>   TRUE \n#> 0.8596\n```\n:::\n\n\n\n\nIn maniera equivalente otteniamo i valori dei partecipanti \"borderline\":\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntable(SDQ$s_emotion == 6)[2] / length(SDQ$s_emotion)\n#>    TRUE \n#> 0.05702\n```\n:::\n\n\n\n\ne dei partecipanti \"non-normali\":\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntable(SDQ$s_emotion >= 7)[2] / length(SDQ$s_emotion)\n#>    TRUE \n#> 0.08333\n```\n:::\n\n\n\n\n## Item reverse\n\nIn un secondo esempio consideriamo la codifica delle risposte degli item SDQ che misurano i Problemi di Condotta. Alcuni item sono stati codificati usando una codifica inversa. Prima di calcolare il punteggio totale è dunque necessario invertire il punteggio degli item a codifica inversa.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nitems_conduct <- c(\"tantrum\", \"obeys\", \"fights\", \"lies\", \"steals\")\n```\n:::\n\n\n\n\nPer i Problemi di Condotta, abbiamo solo un item reverse, `obeys`. \n\n```\ntantrum    obeys*      fights       lies       steals\n```\n\nPer invertire il codice di questo item, useremo una funzione dedicata del pacchetto **psych**, `reverse.code()`. Questa funzione ha la forma generale `reverse.code(keys, items,…)`. L'argomento `keys` è un vettore di valori 1 o -1, dove -1 implica l'inversione dell'item. L'argomento `items` sono i nomi delle variabili che vogliamo valutare. \n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nR_conduct <- reverse.code(keys = c(1, -1, 1, 1, 1), SDQ[, items_conduct]) |> \n  as_tibble()\nR_conduct |> \n  head()\n#> # A tibble: 6 × 5\n#>   tantrum `obeys-` fights  lies steals\n#>     <dbl>    <dbl>  <dbl> <dbl>  <dbl>\n#> 1       0        0      0     0      0\n#> 2       0        0      0     0      0\n#> 3       0        0      0     0      0\n#> 4       0        0      0     0      0\n#> 5       1        2      0     2      0\n#> 6       0        0      0     0      0\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nSDQ[, items_conduct] |> head()\n#> # A tibble: 6 × 5\n#>   tantrum obeys fights  lies steals\n#>     <dbl> <dbl>  <dbl> <dbl>  <dbl>\n#> 1       0     2      0     0      0\n#> 2       0     2      0     0      0\n#> 3       0     2      0     0      0\n#> 4       0     2      0     0      0\n#> 5       1     0      0     2      0\n#> 6       0     2      0     0      0\n```\n:::\n\n\n\n\nAnche in questo caso ci sono dei dati mancanti.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsummary(R_conduct)\n#>     tantrum          obeys-          fights           lies      \n#>  Min.   :0.000   Min.   :0.000   Min.   :0.000   Min.   :0.000  \n#>  1st Qu.:0.000   1st Qu.:0.000   1st Qu.:0.000   1st Qu.:0.000  \n#>  Median :0.000   Median :1.000   Median :0.000   Median :0.000  \n#>  Mean   :0.571   Mean   :0.579   Mean   :0.193   Mean   :0.544  \n#>  3rd Qu.:1.000   3rd Qu.:1.000   3rd Qu.:0.000   3rd Qu.:1.000  \n#>  Max.   :2.000   Max.   :2.000   Max.   :2.000   Max.   :2.000  \n#>  NA's   :2                                       NA's   :2      \n#>      steals     \n#>  Min.   :0.000  \n#>  1st Qu.:0.000  \n#>  Median :0.000  \n#>  Mean   :0.185  \n#>  3rd Qu.:0.000  \n#>  Max.   :2.000  \n#>  NA's   :1\n```\n:::\n\n\n\n\nUsiamo la stessa procedura descritta in precedenza:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nR_conduct <- R_conduct %>%\n    mutate_at(\n      vars(tantrum:steals), ~ ifelse(is.na(.), mean(., na.rm = TRUE), .)\n    )\n```\n:::\n\n\n\n\nCalcoliamo ora il punteggio totale.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nSDQ$s_conduct <- rowMeans(R_conduct)\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nSDQ |>\n    ggplot(aes(x = s_conduct)) +\n    geom_histogram(bins = 10)\n```\n\n::: {.cell-output-display}\n![](E1_likert_files/figure-html/unnamed-chunk-23-1.png){fig-align='center' width=70%}\n:::\n:::\n\n\n\n\n## Session Info\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsessionInfo() \n#> R version 4.4.2 (2024-10-31)\n#> Platform: aarch64-apple-darwin20\n#> Running under: macOS Sequoia 15.3.2\n#> \n#> Matrix products: default\n#> BLAS:   /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRblas.0.dylib \n#> LAPACK: /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.0\n#> \n#> locale:\n#> [1] C/UTF-8/C/C/C/C\n#> \n#> time zone: Europe/Rome\n#> tzcode source: internal\n#> \n#> attached base packages:\n#> [1] stats     graphics  grDevices utils     datasets  methods   base     \n#> \n#> other attached packages:\n#>  [1] ggokabeito_0.1.0  see_0.11.0        MASS_7.3-65       viridis_0.6.5    \n#>  [5] viridisLite_0.4.2 ggpubr_0.6.0      ggExtra_0.10.1    gridExtra_2.3    \n#>  [9] patchwork_1.3.0   bayesplot_1.11.1  semTools_0.5-6    semPlot_1.1.6    \n#> [13] lavaan_0.6-19     psych_2.4.12      scales_1.3.0      markdown_1.13    \n#> [17] knitr_1.50        lubridate_1.9.4   forcats_1.0.0     stringr_1.5.1    \n#> [21] dplyr_1.1.4       purrr_1.0.4       readr_2.1.5       tidyr_1.3.1      \n#> [25] tibble_3.2.1      ggplot2_3.5.1     tidyverse_2.0.0   here_1.0.1       \n#> \n#> loaded via a namespace (and not attached):\n#>   [1] rstudioapi_0.17.1   jsonlite_1.9.1      magrittr_2.0.3     \n#>   [4] TH.data_1.1-3       estimability_1.5.1  farver_2.1.2       \n#>   [7] nloptr_2.2.1        rmarkdown_2.29      vctrs_0.6.5        \n#>  [10] minqa_1.2.8         base64enc_0.1-3     rstatix_0.7.2      \n#>  [13] htmltools_0.5.8.1   broom_1.0.7         Formula_1.2-5      \n#>  [16] htmlwidgets_1.6.4   plyr_1.8.9          sandwich_3.1-1     \n#>  [19] emmeans_1.10.7      zoo_1.8-13          igraph_2.1.4       \n#>  [22] mime_0.13           lifecycle_1.0.4     pkgconfig_2.0.3    \n#>  [25] Matrix_1.7-3        R6_2.6.1            fastmap_1.2.0      \n#>  [28] rbibutils_2.3       shiny_1.10.0        digest_0.6.37      \n#>  [31] OpenMx_2.21.13      fdrtool_1.2.18      colorspace_2.1-1   \n#>  [34] rprojroot_2.0.4     Hmisc_5.2-3         labeling_0.4.3     \n#>  [37] timechange_0.3.0    abind_1.4-8         compiler_4.4.2     \n#>  [40] withr_3.0.2         glasso_1.11         htmlTable_2.4.3    \n#>  [43] backports_1.5.0     carData_3.0-5       ggsignif_0.6.4     \n#>  [46] corpcor_1.6.10      gtools_3.9.5        tools_4.4.2        \n#>  [49] pbivnorm_0.6.0      foreign_0.8-88      zip_2.3.2          \n#>  [52] httpuv_1.6.15       nnet_7.3-20         glue_1.8.0         \n#>  [55] quadprog_1.5-8      nlme_3.1-167        promises_1.3.2     \n#>  [58] lisrelToR_0.3       grid_4.4.2          checkmate_2.3.2    \n#>  [61] cluster_2.1.8.1     reshape2_1.4.4      generics_0.1.3     \n#>  [64] gtable_0.3.6        tzdb_0.5.0          data.table_1.17.0  \n#>  [67] hms_1.1.3           car_3.1-3           sem_3.1-16         \n#>  [70] pillar_1.10.1       rockchalk_1.8.157   later_1.4.1        \n#>  [73] splines_4.4.2       lattice_0.22-6      survival_3.8-3     \n#>  [76] kutils_1.73         tidyselect_1.2.1    miniUI_0.1.1.1     \n#>  [79] pbapply_1.7-2       reformulas_0.4.0    stats4_4.4.2       \n#>  [82] xfun_0.51           qgraph_1.9.8        arm_1.14-4         \n#>  [85] stringi_1.8.4       yaml_2.3.10         pacman_0.5.1       \n#>  [88] boot_1.3-31         evaluate_1.0.3      codetools_0.2-20   \n#>  [91] mi_1.1              cli_3.6.4           RcppParallel_5.1.10\n#>  [94] rpart_4.1.24        xtable_1.8-4        Rdpack_2.6.3       \n#>  [97] munsell_0.5.1       Rcpp_1.0.14         coda_0.19-4.1      \n#> [100] png_0.1-8           XML_3.99-0.18       parallel_4.4.2     \n#> [103] jpeg_0.1-10         lme4_1.1-36         mvtnorm_1.3-3      \n#> [106] openxlsx_4.2.8      rlang_1.1.5         multcomp_1.4-28    \n#> [109] mnormt_2.1.1\n```\n:::\n",
    "supporting": [
      "E1_likert_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}