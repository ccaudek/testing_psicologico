{
  "hash": "7785a22abf6497900cfe19ac98e9617f",
  "result": {
    "engine": "knitr",
    "markdown": "# Modelli 1PL, 2PL e 3PL {#sec-irt-123pl}\n\n::: callout-important  \n## In questo capitolo apprenderai come:\n\n- adattare e interpretare i modelli IRT: 1PL, 2PL e 3PL, comprendendo le differenze concettuali e pratiche tra loro;  \n- analizzare il principio dell'invarianza di gruppo e la sua importanza per confronti equi tra popolazioni diverse.  \n:::  \n\n::: callout-tip\n## Prerequisiti\n\n- Leggere il capitolo 8, *Item Response Theory*, del testo *Principles of psychological assessment* di @petersen2024principles. \n:::\n\n::: callout-caution\n## Preparazione del Notebook\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhere::here(\"code\", \"_common.R\") |> \n  source()\n\n# Load packages\nif (!requireNamespace(\"pacman\")) install.packages(\"pacman\")\npacman::p_load(eRm, mirt, grid, TAM, ggmirt, psychotools, latex2exp)\n```\n:::\n\n\n\n:::\n\n## Introduzione\n\nAll'interno della teoria della risposta agli item (IRT), il **modello di Rasch** rappresenta l'approccio più restrittivo, poiché impone vincoli stringenti sulle relazioni tra abilità delle persone e difficoltà degli item. Questi vincoli garantiscono semplicità e proprietà matematiche utili, ma limitano la flessibilità del modello nel rappresentare dati complessi.\n\nProgressivamente, tali restrizioni possono essere allentate per definire modelli più flessibili:\n\n- Il **modello 1PL (One-Parameter Logistic)**, che conserva l'assunzione di uguale discriminazione tra gli item ma non richiede tutte le proprietà rigorose del modello di Rasch.  \n- Il **modello 2PL (Two-Parameter Logistic)**, che introduce un parametro aggiuntivo per descrivere la capacità discriminante degli item, consentendo una rappresentazione più accurata delle risposte.  \n- Il **modello 3PL (Three-Parameter Logistic)**, che aggiunge un terzo parametro per tenere conto della probabilità di risposta corretta casuale (detta anche \"guessing\").  \n\nQuesta progressione da Rasch a 1PL, 2PL e 3PL permette una maggiore adattabilità del modello IRT, bilanciando semplicità e flessibilità a seconda delle esigenze specifiche dei dati e dell’analisi.\n\n## Un Esempio Pratico\n\nIn questo capitolo, utilizzeremo nuovamente i dati che abbiamo esaminato in precedenza nel @sec-irt-estimation. \n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndata(data.fims.Aus.Jpn.scored, package = \"TAM\")\nfims <- data.fims.Aus.Jpn.scored\n```\n:::\n\n\n\n\nIl data set include 400 partecipanti. Per facilitare la manipolazione dei dati, cambiamo il nome delle colonne.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nresponses <- fims[1:400, 2:15]\ncolnames(responses) <- gsub(\"M1PTI\", \"I\", colnames(responses))\nglimpse(responses)\n#> Rows: 400\n#> Columns: 14\n#> $ I1  <dbl> 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1,…\n#> $ I2  <dbl> 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1,…\n#> $ I3  <dbl> 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1,…\n#> $ I6  <dbl> 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0,…\n#> $ I7  <dbl> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n#> $ I11 <dbl> 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0,…\n#> $ I12 <dbl> 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n#> $ I14 <dbl> 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0,…\n#> $ I17 <dbl> 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0,…\n#> $ I18 <dbl> 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0,…\n#> $ I19 <dbl> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n#> $ I21 <dbl> 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,…\n#> $ I22 <dbl> 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,…\n#> $ I23 <dbl> 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0,…\n```\n:::\n\n\n\n\nDefiniamo il fattore `gender`:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngender <- as.factor(fims$SEX[1:400])\nlevels(gender) <- c(\"male\", \"female\")\n\ngender |> table()\n#> gender\n#>   male female \n#>    246    154\n```\n:::\n\n\n\n\n\n## Modello 1PL\n\nIl **modello ad un parametro logistico (1PL)** descrive la probabilità che un rispondente con un certo livello di abilità dia una risposta corretta a un item specifico. La formula del modello è:\n\n$$\nP(X_i = 1 \\mid \\theta_v, \\alpha, \\delta_i) = \\frac{\\exp(\\alpha(\\theta_v - \\delta_i))}{1 + \\exp(\\alpha(\\theta_v - \\delta_i))} = \\frac{1}{1 + \\exp(-\\alpha(\\theta_v - \\delta_i))}, \\tag{1}\n$$\n\ndove:\n\n- $\\theta_v$ è il livello di abilità del rispondente $v$,\n- $\\delta_i$ è il parametro di difficoltà dell'item $i$,\n- $\\alpha$ è il parametro di discriminazione dell'item, fissato e uguale per tutti gli item nel modello 1PL.\n\nL'assunzione fondamentale del modello 1PL è che **$\\alpha$ sia costante** per tutti gli item, indicando che tutti gli item hanno la stessa capacità di discriminazione tra rispondenti con abilità diverse.\n\n### Il Ruolo del Parametro $\\alpha$\n\nIl parametro $\\alpha$ definisce la pendenza della curva caratteristica dell'item (ICC). Maggiore è $\\alpha$, più ripida è la curva ICC, e maggiore è la capacità dell'item di discriminare tra rispondenti con abilità vicine alla difficoltà dell'item ($\\delta_i$).  \n\n- $\\alpha = 0$: L'item non discrimina affatto; la probabilità di risposta corretta è costante e indipendente dal livello di abilità.\n- $\\alpha > 0$: L'item discrimina, e la sua capacità discriminatoria cresce con l'aumento di $\\alpha$.\n\n### Esempio Pratico\n\nConsideriamo tre item ($i_1$, $i_2$, $i_3$) con la stessa difficoltà $\\delta = 0$ e tre valori di discriminazione: $\\alpha_1 = 0.0$, $\\alpha_2 = 1.0$ e $\\alpha_3 = 2.0$. Esaminiamo due rispondenti con livelli di abilità:\n\n- Rispondente A con $\\theta_A = -1$,\n- Rispondente B con $\\theta_B = 1$.\n\n**Item con $\\alpha = 0.0**  \n\nCon $\\alpha = 0$, la probabilità di risposta corretta è costante, pari a 0.5 per tutti i livelli di abilità:\n\n$$\nP(X_i = 1 \\mid \\theta, \\delta) = 0.5.\n$$\n\nQuesto item non discrimina tra rispondenti con abilità diverse e non aggiunge alcuna informazione utile.\n\n**Item con $\\alpha$ = 1.0** \n\nCon $\\alpha = 1.0$, la probabilità di risposta corretta dipende dal livello di abilità:\n\n$$\nP(X_i = 1 \\mid \\theta, \\delta) = \\frac{1}{1 + \\exp(-(\\theta - \\delta))}.\n$$\n\n- Per $\\theta_A = -1$: $P(X_i = 1) \\approx 0.269$,\n- Per $\\theta_B = 1$: $P(X_i = 1) \\approx 0.731$.\n\nLa curva ICC è moderatamente ripida e l'item discrimina tra rispondenti con abilità diverse.\n\n**Item con $\\alpha$ = 2.0** \n\nCon $\\alpha = 2.0$, l'ICC diventa più ripida:\n\n$$\nP(X_i = 1 \\mid \\theta, \\delta) = \\frac{1}{1 + \\exp(-2(\\theta - \\delta))}.\n$$\n\n- Per $\\theta_A = -1$: $P(X_i = 1) \\approx 0.119$,\n- Per $\\theta_B = 1$: $P(X_i = 1) \\approx 0.881$.\n\nLa maggiore ripidità riflette una capacità discriminatoria più alta, permettendo di distinguere con maggiore precisione i rispondenti in base alle loro abilità.\n\nIn conclusione, nel modello 1PL, il parametro $\\alpha$ controlla la capacità degli item di discriminare tra rispondenti con abilità diverse. Un aumento di $\\alpha$ rende la curva ICC più ripida, migliorando la discriminazione, mentre un $\\alpha$ più basso rende la curva piatta e riduce la capacità informativa dell'item. Tuttavia, nel 1PL, l'assunzione che $\\alpha$ sia costante per tutti gli item rappresenta un limite rispetto ai modelli più complessi, come il 2PL, che permettono a ogni item di avere una discriminazione diversa.\n\n### Modello di Rasch e Modello 1PL: Confronto e Differenze\n\nIl modello di Rasch e il modello 1PL (One-Parameter Logistic) sono due approcci alla misurazione che condividono una struttura matematica simile. Entrambi utilizzano un parametro di discriminazione (α) costante per tutti gli item, pur permettendo variazioni nei parametri di difficoltà (δᵢ). \n\nLa differenza tecnica principale sta nel valore del parametro α:\n\n- Nel modello di Rasch, α è sempre fissato a 1.0\n- Nel modello 1PL, α può assumere qualsiasi valore costante, anche diverso da 1.0\n\nMatematicamente, i due modelli sono equivalenti: è possibile convertire i parametri da un modello all'altro attraverso una semplice riscalatura, moltiplicando o dividendo θᵥ e δᵢ per α, mantenendo invariate le probabilità di risposta corretta.\n\nNonostante la loro equivalenza matematica, i due modelli si distinguono per filosofia e obiettivi:\n\nIl modello 1PL si concentra sull'adattamento ai dati empirici:\n\n- Mira a descrivere al meglio i dati osservati\n- Offre flessibilità nella scelta del parametro α\n- Si adatta ai dati esistenti\n\nIl modello di Rasch privilegia la misurazione oggettiva:\n\n- Pone l'enfasi sulla costruzione di misure stabili e generalizzabili\n- Considera il modello come uno standard di riferimento\n- Richiede che i dati si conformino al modello, non viceversa\n- Si pone come strumento per sviluppare misurazioni valide e oggettive\n\nIn sintesi, mentre il modello 1PL è più orientato alla descrizione statistica dei dati, il modello di Rasch si propone come standard per la costruzione di strumenti di misurazione oggettivi e universalmente applicabili.\n\n::: {#exr-}\nIn $\\mathsf{R}$, il modello di Rasch si implementa nel modo seguente:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmirt_rm <- mirt(responses, 1, \"Rasch\", verbose = FALSE)\n```\n:::\n\n\n\n\nIl modello 1PL si implementa nel modo seguente:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmirt_1pl <- mirt(responses, 1, \"1PL\", verbose = FALSE)\n```\n:::\n\n\n\n\nConfrontiamo i due modelli:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nanova(mirt_rm, mirt_1pl)\n#>           AIC SABIC   HQ  BIC logLik     X2 df   p\n#> mirt_rm  5663  5675 5687 5723  -2816              \n#> mirt_1pl 5662  5673 5684 5718  -2817 -0.705 -1 NaN\n```\n:::\n\n\n\n\nI modelli `mirt_rm` e `mirt_1pl` sono praticamente equivalenti in termini di adattamento ai dati. Il modello `mirt_1pl` mostra lievi miglioramenti nei criteri di informazione (AIC e BIC), ma la differenza è minima.\n:::\n\n### Modello 2PL\n\nIl **modello 2PL** (Modello IRT a due parametri) rappresenta un’estensione del modello 1PL che consente una maggiore flessibilità, poiché permette alle Curve Caratteristiche degli Item (ICC) di avere pendenze diverse. Questo significa che, a differenza del modello 1PL e del modello di Rasch, le ICC degli item non sono necessariamente parallele. Nel modello 2PL, ogni item è descritto da due parametri fondamentali:\n\n1. **Parametro di difficoltà ($b$):** Indica il livello di abilità ($\\theta$) a cui la probabilità di risposta corretta è del 50%. Determina il posizionamento della curva ICC lungo l’asse delle abilità.\n2. **Parametro di discriminazione ($a$):** Regola la pendenza della curva ICC, rappresentando la capacità dell’item di distinguere tra rispondenti con abilità simili. Un valore più alto di $a$ indica una maggiore sensibilità dell’item alle variazioni di abilità.\n\nLa formula generale per le ICC nel modello 2PL è:\n\n$$\nP(X_i = 1 \\mid \\theta, a_i, b_i) = \\frac{1}{1 + \\exp(-a_i (\\theta - b_i))},\n$$\n\ndove:\n\n- $\\theta$ rappresenta l’abilità del rispondente,\n- $a_i$ è il parametro di discriminazione per l’item $i$,\n- $b_i$ è il parametro di difficoltà per l’item $i$.\n\n\n### Implementazione in R con il Pacchetto `mirt`\n\nUtilizziamo il pacchetto **mirt** per adattare il modello 2PL ai dati. Il comando `mirt()` permette di stimare i parametri specificando il modello 2PL:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmirt_2pl <- mirt(responses, 1, \"2PL\")\n#> \nIteration: 1, Log-Lik: -2818.855, Max-Change: 0.66304\nIteration: 2, Log-Lik: -2772.597, Max-Change: 0.26013\nIteration: 3, Log-Lik: -2762.517, Max-Change: 0.12884\nIteration: 4, Log-Lik: -2760.353, Max-Change: 0.06587\nIteration: 5, Log-Lik: -2759.824, Max-Change: 0.03961\nIteration: 6, Log-Lik: -2759.675, Max-Change: 0.02169\nIteration: 7, Log-Lik: -2759.622, Max-Change: 0.01040\nIteration: 8, Log-Lik: -2759.609, Max-Change: 0.00642\nIteration: 9, Log-Lik: -2759.605, Max-Change: 0.00396\nIteration: 10, Log-Lik: -2759.602, Max-Change: 0.00160\nIteration: 11, Log-Lik: -2759.602, Max-Change: 0.00089\nIteration: 12, Log-Lik: -2759.602, Max-Change: 0.00064\nIteration: 13, Log-Lik: -2759.601, Max-Change: 0.00020\nIteration: 14, Log-Lik: -2759.601, Max-Change: 0.00009\n```\n:::\n\n\n\n\nPer analizzare graficamente le Curve Caratteristiche degli Item, usiamo la funzione `plot()`:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplot(mirt_2pl, type = \"trace\")\n```\n\n::: {.cell-output-display}\n![](04_1pl_2pl_3pl_files/figure-html/unnamed-chunk-9-1.png){fig-align='center' width=70%}\n:::\n:::\n\n\n\n\nSe desideriamo visualizzare tutte le ICC in un unico grafico, senza separarle per item, aggiungiamo l’opzione `facet_items = FALSE`:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplot(mirt_2pl, type = \"trace\", facet_items = FALSE)\n```\n\n::: {.cell-output-display}\n![](04_1pl_2pl_3pl_files/figure-html/unnamed-chunk-10-1.png){fig-align='center' width=70%}\n:::\n:::\n\n\n\n\nLa funzione `coef()` consente di ottenere le stime dei parametri degli item:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncoef(mirt_2pl, IRTpars = TRUE, simplify = TRUE)\n#> $items\n#>          a      b g u\n#> I1   1.147 -1.022 0 1\n#> I2   1.769 -0.911 0 1\n#> I3   1.372 -1.680 0 1\n#> I6   1.479 -0.043 0 1\n#> I7   1.071  2.441 0 1\n#> I11  1.594 -0.957 0 1\n#> I12  0.703  1.079 0 1\n#> I14  0.771 -0.612 0 1\n#> I17  0.707  1.758 0 1\n#> I18  0.750 -0.502 0 1\n#> I19  1.831  1.459 0 1\n#> I21 -0.214 -7.076 0 1\n#> I22  0.277  7.657 0 1\n#> I23  1.521 -1.503 0 1\n#> \n#> $means\n#> F1 \n#>  0 \n#> \n#> $cov\n#>    F1\n#> F1  1\n```\n:::\n\n\n\n\nQueste stime includono:\n\n- $a$, parametro di discriminazione,\n- $b$, parametro di difficoltà.\n\n### Confronto tra Modello 1PL e Modello 2PL\n\nPer valutare quale modello si adatta meglio ai dati, confrontiamo il modello 1PL (discriminazione fissa) con il modello 2PL (discriminazione variabile) utilizzando la funzione `anova()`:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nanova(mirt_rm, mirt_2pl)\n#>           AIC SABIC   HQ  BIC logLik     X2 df p\n#> mirt_rm  5663  5675 5687 5723  -2816            \n#> mirt_2pl 5575  5598 5619 5687  -2760 113.77 13 0\n```\n:::\n\n\n\n\n**Interpretazione dei Risultati**\n\n1. **Criteri di Informazione (AIC e BIC):** Il modello 2PL tipicamente mostra valori di AIC e BIC più bassi rispetto al modello 1PL, indicando un miglior adattamento ai dati.\n2. **Log-Likelihood:** Il modello 2PL presenta un log-likelihood superiore rispetto al modello 1PL, a indicare una maggiore probabilità di osservare i dati sotto il modello 2PL.\n3. **Test di $X^2$:** Se il p-value associato è significativo ($p < 0.05$), ciò suggerisce che il modello 2PL spiega significativamente più variazione rispetto al modello 1PL.\n\n\n### Differenze Chiave tra Modello 1PL e Modello 2PL\n\n| **Caratteristica**          | **Modello 1PL**                              | **Modello 2PL**                              |\n|-----------------------------|---------------------------------------------|---------------------------------------------|\n| **Parametro di discriminazione ($a$)** | Fisso per tutti gli item ($a = \\alpha$ costante) | Variabile tra gli item ($a_i$ specifico)    |\n| **Curva ICC**               | Tutte le curve ICC sono parallele          | Le curve ICC possono avere pendenze diverse |\n| **Adattamento ai dati**     | Meno flessibile, buono per dati uniformi   | Più flessibile, cattura differenze di discriminazione |\n\nIn conclusione, il modello 2PL è particolarmente utile quando gli item differiscono nella loro capacità di discriminare tra rispondenti con abilità simili. Questo lo rende una scelta preferibile rispetto al modello 1PL in situazioni in cui gli item non sono omogenei in termini di discriminazione. Tuttavia, la maggiore flessibilità del modello 2PL comporta una maggiore complessità e richiede un dataset con sufficiente variabilità per stimare accuratamente i parametri $a_i$ e $b_i$.\n\n## Modello 3PL\n\nIl **modello IRT a tre parametri (3PL)** è un’estensione del modello 2PL che aggiunge un terzo parametro, il **guessing** ($g$), per tenere conto della probabilità di rispondere correttamente a un item semplicemente per caso. Questo parametro è particolarmente utile nei test a scelta multipla, dove i rispondenti con abilità molto bassa possono comunque selezionare la risposta corretta in modo casuale.\n\nLa probabilità di risposta corretta nel modello 3PL è espressa come:\n\n$$\nP(X_i = 1 \\mid \\theta, a_i, b_i, g_i) = g_i + (1 - g_i) \\cdot \\frac{1}{1 + \\exp(-a_i (\\theta - b_i))},\n$$\n\ndove:\n\n- $\\theta$: abilità latente del rispondente,\n- $a_i$: parametro di discriminazione dell’item $i$ (controlla la pendenza della curva ICC),\n- $b_i$: parametro di difficoltà dell’item $i$ (indica il livello di abilità richiesto per una probabilità del 50% di risposta corretta, escludendo il guessing),\n- $g_i$: parametro di guessing (probabilità minima di rispondere correttamente a un item, anche per rispondenti con abilità molto bassa).\n\n### Caratteristiche del Modello 3PL\n\n1. **Parametro di Guessing ($g$):**\n   - Introduce un asintoto inferiore maggiore di zero nella curva caratteristica dell’item (ICC).\n   - Ad esempio, un valore $g_i = 0.25$ indica che, anche per abilità molto basse ($\\theta \\to -\\infty$), la probabilità di rispondere correttamente all’item è almeno del 25%. Questo valore è tipico per test a scelta multipla con quattro opzioni, dove c'è il 25% di probabilità di indovinare.\n\n2. **Relazione con il Modello 2PL:**\n   - Il modello 3PL generalizza il modello 2PL aggiungendo il parametro $g$, che aumenta la flessibilità per rappresentare meglio il comportamento degli item in situazioni reali.\n   - Mentre nel modello 2PL la probabilità di risposta corretta può scendere a zero per abilità molto basse, nel modello 3PL la probabilità minima è definita da $g$.\n\n3. **Curve Caratteristiche degli Item (ICC):**\n   - La presenza del parametro $g$ modifica la forma della curva ICC, che non tocca mai lo zero ma si avvicina asintoticamente al valore di $g$ per $\\theta$ molto basso.\n\n4. **Complessità del Modello:**\n   - L’aggiunta del parametro $g$ rende il modello più complesso rispetto al 2PL, aumentando il numero di parametri da stimare.\n   - Per ottenere stime affidabili, è necessario disporre di un dataset con un numero sufficiente di item e rispondenti.\n\n::: {#exr-}\n\nUtilizziamo il pacchetto **mirt** per stimare i parametri del modello 3PL:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmirt_3pl <- mirt(responses, 1, \"3PL\")\n```\n:::\n\n\n\n\nLe curve ICC possono essere visualizzate con il comando:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplot(mirt_3pl, type = \"trace\", facet_items = TRUE)\n```\n\n::: {.cell-output-display}\n![](04_1pl_2pl_3pl_files/figure-html/unnamed-chunk-14-1.png){fig-align='center' width=70%}\n:::\n:::\n\n\n\n\nUtilizziamo la funzione `coef()` per ottenere le stime dei parametri degli item ($a$, $b$, $g$):\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncoef(mirt_3pl, IRTpars = TRUE, simplify = TRUE)\n#> $items\n#>          a      b     g u\n#> I1   1.410 -0.493 0.244 1\n#> I2   2.667 -0.404 0.291 1\n#> I3   1.445 -1.633 0.000 1\n#> I6   1.514  0.009 0.019 1\n#> I7   1.163  2.297 0.000 1\n#> I11  1.487 -0.984 0.000 1\n#> I12  2.131  1.275 0.207 1\n#> I14  0.805 -0.586 0.000 1\n#> I17  3.076  1.320 0.138 1\n#> I18  0.724 -0.510 0.000 1\n#> I19  1.844  1.449 0.000 1\n#> I21 -5.264 -2.271 0.167 1\n#> I22  9.179  1.990 0.090 1\n#> I23  1.625 -1.452 0.000 1\n#> \n#> $means\n#> F1 \n#>  0 \n#> \n#> $cov\n#>    F1\n#> F1  1\n```\n:::\n\n\n\n\n**Confronto tra modelli 2PL e 3PL**\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nanova(mirt_2pl, mirt_3pl)\n#>           AIC SABIC   HQ  BIC logLik     X2 df p\n#> mirt_2pl 5575  5598 5619 5687  -2760            \n#> mirt_3pl 5564  5599 5631 5732  -2740 38.784 14 0\n```\n:::\n\n\n\n\n- Il **modello 3PL** presenta un AIC inferiore rispetto al modello 2PL, suggerendo un miglior adattamento ai dati.\n- Tuttavia, il BIC penalizza maggiormente la complessità del modello, favorendo leggermente il modello 2PL.\n- La significatività del test $X^2$ ($p = 0.0004$) indica che il modello 3PL offre un miglioramento significativo rispetto al modello 2PL.\n\n**Valutazione della bontà dell’adattamento**\n\nPer verificare se il modello 3PL rappresenta adeguatamente i dati, utilizziamo la statistica $M2$:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nM2(mirt_3pl)\n#>          M2 df     p  RMSEA RMSEA_5 RMSEA_95   SRMSR    TLI    CFI\n#> stats 76.06 63 0.125 0.0228       0  0.03944 0.04533 0.9751 0.9827\n```\n:::\n\n\n\n\n- Il valore $p = 0.125$ indica che il modello 3PL non può essere rifiutato come rappresentazione adeguata dei dati.\n- Il **RMSEA** inferiore a 0.05 (limite superiore: 0.039) suggerisce un buon adattamento.\n\n**Adattamento degli item**\n\nIl comando `itemfit()` calcola le statistiche di adattamento (fit) per ciascun item del modello 3PL, fornendo i valori di infit e outfit insieme ai relativi z-score che indicano quanto questi valori si discostano da quelli attesi secondo una distribuzione normale standardizzata.\n\n- L'infit (*Information-weighted fit*) si concentra principalmente sui rispondenti con un livello di abilità simile alla difficoltà dell'item, ed è quindi particolarmente sensibile alle discrepanze nella \"zona di interesse\" dell'item, dove la probabilità di risposta corretta si aggira intorno al 50%. \n- L'outfit (*Outlier-sensitive fit*) invece considera tutti i rispondenti, inclusi quelli con abilità molto diverse dalla difficoltà dell'item, risultando più sensibile a risposte inaspettate o estreme.\n\nPer entrambe le statistiche, valori compresi tra 0.7 e 1.3 indicano un buon adattamento dell'item al modello. Valori inferiori a 0.7 suggeriscono che l'item è troppo prevedibile o ridondante, mentre valori superiori a 1.3 indicano la presenza di risposte inaspettate. Per quanto riguarda gli z-score, valori con modulo inferiore a 2 sono considerati accettabili, mentre valori superiori potrebbero indicare problemi di adattamento.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nitemfit(mirt_3pl, \"infit\", method = \"ML\") # infit and outfit stats\n#>    item outfit z.outfit infit z.infit\n#> 1    I1  1.005    0.084 0.983  -0.273\n#> 2    I2  0.865   -0.367 0.873  -2.016\n#> 3    I3  0.876   -0.404 0.909  -0.940\n#> 4    I6  0.981   -0.145 0.916  -1.503\n#> 5    I7  0.783   -0.797 0.896  -0.899\n#> 6   I11  1.462    2.383 0.886  -1.567\n#> 7   I12  0.945   -0.929 0.942  -1.157\n#> 8   I14  0.967   -0.565 1.009   0.223\n#> 9   I17  0.784   -2.457 0.807  -2.709\n#> 10  I18  1.025    0.539 1.013   0.349\n#> 11  I19  0.590   -1.393 0.816  -2.165\n#> 12  I21  0.915   -0.983 0.917  -0.963\n#> 13  I22  0.860   -0.978 0.844  -1.160\n#> 14  I23  0.778   -0.736 0.872  -1.370\n```\n:::\n\n\n\n\nDall'analisi dei risultati emerge che la maggior parte degli item mostra un buon adattamento al modello. In particolare, l'item I1 presenta valori ottimali sia per outfit (1.005) che per infit (0.983), con z-score molto contenuti (0.084 e -0.273 rispettivamente). Anche gli item I3, I6, I14, I18 e I21 mostrano valori di adattamento soddisfacenti, rientrando negli intervalli di accettabilità sia per le statistiche di fit che per gli z-score.\n\nTuttavia, alcuni item presentano aspetti critici che meritano attenzione. L'item I11 mostra un outfit elevato (1.462) con uno z-score significativo (2.383), suggerendo la presenza di risposte anomale da parte di soggetti con livelli di abilità distanti dalla difficoltà dell'item. L'item I17, pur avendo valori di fit accettabili (outfit = 0.784, infit = 0.807), presenta uno z-score problematico per l'infit (-2.709), indicando possibili discrepanze significative per i rispondenti con abilità vicine alla difficoltà dell'item.\n\nUn caso particolare è rappresentato dall'item I19, che mostra un outfit inferiore alla soglia minima (0.590) e uno z-score dell'infit significativo (-2.165). Questi valori potrebbero indicare che l'item è troppo prevedibile o eccessivamente facile rispetto al livello atteso dal modello.\n\nNel complesso, sebbene la maggior parte degli item mostri un adattamento soddisfacente, potrebbe essere opportuno rivedere gli item I11, I17 e I19 per migliorare la qualità complessiva dello strumento di misura.\n\n:::\n\n## Invarianza di Gruppo nella Item Response Theory\n\nL'invarianza di gruppo dei parametri degli item rappresenta una delle caratteristiche più importanti della IRT. Questo principio afferma che le proprietà misurate di un item - come la sua difficoltà, discriminazione e probabilità di indovinare la risposta corretta - sono caratteristiche intrinseche dell'item stesso e rimangono stabili indipendentemente dalla popolazione di riferimento.\n\nPer comprendere meglio questo concetto, consideriamo un esempio concreto. Immaginiamo di somministrare lo stesso test a due gruppi distinti di esaminandi:\n\n- il primo gruppo è composto da individui con abilità relativamente bassa, con punteggi che variano tra -3 e -1 sulla scala di abilità (con una media di -2);\n- il secondo gruppo invece include individui con abilità più elevata, con punteggi tra +1 e +3 (media +2).\n\nQuando analizziamo le risposte utilizzando il metodo della massima verosimiglianza, osserviamo un fenomeno notevole: per ogni item, otteniamo gli stessi parametri indipendentemente dal gruppo analizzato. Per esempio, se per un determinato item otteniamo un parametro di discriminazione a = 1.27 e un parametro di difficoltà b = 0.39 analizzando l'intero campione, ritroveremo sostanzialmente gli stessi valori anche analizzando separatamente il gruppo con abilità bassa o quello con abilità alta.\n\nQuesto risultato ha implicazioni pratiche molto importanti. Significa che:\n\n1. le caratteristiche dell'item rimangono stabili anche quando il test viene somministrato a popolazioni diverse;\n2. possiamo confrontare in modo valido le prestazioni di gruppi diversi sullo stesso item;\n3. le stime dei parametri dell'item sono robuste e generalizzabili;\n4. la calibrazione degli item può essere effettuata su un campione e poi applicata con fiducia a popolazioni diverse.\n\nL'invarianza di gruppo rappresenta quindi una proprietà fondamentale che distingue i modelli IRT dai modelli classici della teoria dei test, permettendo confronti più equi e interpretazioni più affidabili dei risultati dei test tra diverse popolazioni.\n\nQuesta proprietà è particolarmente utile in contesti pratici, come quando si devono confrontare gruppi culturali diversi, classi scolastiche di diverso livello, o quando si vuole verificare se un test funziona allo stesso modo per popolazioni diverse. L'invarianza garantisce che le differenze osservate riflettano reali differenze nelle abilità misurate, piuttosto che artefatti dovuti alle caratteristiche del campione utilizzato per la calibrazione.\n\n::: {#exr-}\n\nQuesto esercizio utilizza una simulazione in R per dimostrare visivamente il principio di invarianza dei parametri degli item nella IRT. La funzione `groupinv()` simula le risposte di due gruppi distinti di esaminandi e visualizza le loro curve caratteristiche dell'item (ICC).\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngroupinv <- function(mdl, t1l, t1u, t2l, t2u) {\n    if (missing(t1l)) t1l <- -3\n    if (missing(t1u)) t1u <- -1\n    if (missing(t2l)) t2l <- 1\n    if (missing(t2u)) t2u <- 3\n    theta <- seq(-3, 3, .1875)\n    f <- rep(21, length(theta))\n    wb <- round(runif(1, -3, 3), 2)\n    wa <- round(runif(1, 0.2, 2.8), 2)\n    wc <- round(runif(1, 0, .35), 2)\n    if (mdl == 1 | mdl == 2) {\n        wc <- 0\n    }\n    if (mdl == 1) {\n        wa <- 1\n    }\n    for (g in 1:length(theta)) {\n        P <- wc + (1 - wc) / (1 + exp(-wa * (theta - wb)))\n    }\n    p <- rbinom(length(theta), f, P) / f\n    lowerg1 <- 0\n    for (g in 1:length(theta)) {\n        if (theta[g] <= t1l) {\n            lowerg1 <- lowerg1 + 1\n        }\n    }\n    upperg1 <- 0\n    for (g in 1:length(theta)) {\n        if (theta[g] <= t1u) {\n            upperg1 <- upperg1 + 1\n        }\n    }\n    theta1 <- theta[lowerg1:upperg1]\n    p1 <- p[lowerg1:upperg1]\n    lowerg2 <- 0\n    for (g in 1:length(theta)) {\n        if (theta[g] <= t2l) {\n            lowerg2 <- lowerg2 + 1\n        }\n    }\n    upperg2 <- 0\n    for (g in 1:length(theta)) {\n        if (theta[g] <= t2u) {\n            upperg2 <- upperg2 + 1\n        }\n    }\n    theta2 <- theta[lowerg2:upperg2]\n    p2 <- p[lowerg2:upperg2]\n    theta12 <- c(theta1, theta2)\n    p12 <- c(p1, p2)\n    par(lab = c(7, 5, 3))\n    plot(theta12, p12,\n        xlim = c(-3, 3), ylim = c(0, 1),\n        xlab = \"Ability\", ylab = \"Probability of Correct Response\"\n    )\n    if (mdl == 1) {\n        maintext <- paste(\"Pooled Groups\", \"\\n\", \"b=\", wb)\n    }\n    if (mdl == 2) {\n        maintext <- paste(\"Pooled Groups\", \"\\n\", \"a=\", wa, \"b=\", wb)\n    }\n    if (mdl == 3) {\n        maintext <- paste(\n            \"Pooled Groups\", \"\\n\",\n            \"a=\", wa, \"b=\", wb, \"c=\", wc\n        )\n    }\n    par(new = \"T\")\n    plot(theta, P,\n        xlim = c(-3, 3), ylim = c(0, 1), type = \"l\",\n        xlab = \"\", ylab = \"\", main = maintext\n    )\n}\n\nset.seed(1)\ngroupinv(1, -3, -1, 1, 3)\n```\n\n::: {.cell-output-display}\n![](04_1pl_2pl_3pl_files/figure-html/unnamed-chunk-19-1.png){fig-align='center' width=70%}\n:::\n:::\n\n\n\n\nNel grafico risultante, osserviamo due segmenti di punti che rappresentano le risposte dei due gruppi. La linea continua mostra la curva ICC stimata utilizzando i dati di entrambi i gruppi. Il fatto che questa curva si adatti bene ai punti di entrambi i gruppi, nonostante la loro diversa distribuzione di abilità, dimostra visivamente il principio di invarianza: i parametri dell'item rimangono stabili indipendentemente dal gruppo considerato.\n\nQuesta visualizzazione è particolarmente efficace perché:\n\n1. mostra chiaramente la separazione tra i due gruppi di abilità;\n2. permette di verificare che la stessa curva ICC si adatta bene a entrambi i gruppi;\n3. conferma che le stime dei parametri (riportate nel titolo del grafico) sono valide per l'intero range di abilità.\n\nL'esercizio fornisce quindi una dimostrazione empirica dell'invarianza di gruppo, una delle proprietà fondamentali che rendono la IRT uno strumento robusto per la misurazione psicometrica.\n\n:::\n\n### Confronto con la Teoria Classica dei Test\n\nLa differenza più notevole tra IRT e CTT riguarda proprio il modo in cui viene trattata l'invarianza dei parametri degli item rispetto ai gruppi esaminati. Questo aspetto emerge chiaramente analizzando come le due teorie definiscono e misurano la difficoltà degli item.\n\nNella CTT, la difficoltà di un item è definita come la proporzione di risposte corrette nel campione. Questa definizione rende il parametro di difficoltà intrinsecamente dipendente dalla popolazione esaminata: lo stesso item mostrerà una \"difficoltà\" diversa se somministrato a gruppi con differenti livelli di abilità. Per esempio, se somministriamo un test a due classi di livello diverso, nella CTT otterremo due stime di difficoltà diverse per lo stesso item, rendendo problematico qualsiasi confronto diretto tra i gruppi.\n\nL'IRT risolve questa limitazione fondamentale introducendo parametri che sono teoricamente invarianti rispetto alla popolazione. Il parametro di difficoltà ($\\beta$) in particolare rappresenta una proprietà intrinseca dell'item che rimane costante indipendentemente dal gruppo esaminato. Questo significa che, a differenza della CTT, l'IRT può fornire stime comparabili della difficoltà dell'item anche quando viene somministrato a popolazioni con distribuzioni di abilità molto diverse.\n\nL'invarianza nella IRT si manifesta nella curva caratteristica dell'item (ICC): la relazione tra abilità e probabilità di risposta corretta mantiene la stessa forma matematica indipendentemente dal gruppo considerato (come abbiamo osservato nell'esempio precedente). Questa proprietà ha importanti implicazioni pratiche:\n\n- possiamo stimare i parametri dell'item utilizzando qualsiasi sottogruppo della popolazione e ottenere risultati coerenti;\n- è possibile confrontare direttamente le prestazioni di gruppi diversi sullo stesso item;\n- la calibrazione degli item può essere effettuata su un campione e poi applicata con fiducia ad altri gruppi.\n\nTuttavia, è importante notare che mentre nella CTT la dipendenza dalla popolazione è una limitazione intrinseca del modello, nell'IRT l'invarianza è una proprietà teorica che nella pratica può essere influenzata da vari fattori. Le stime empiriche dei parametri possono mostrare alcune variazioni dovute all'errore campionario, e l'invarianza è garantita solo quando l'item misura effettivamente lo stesso costrutto in tutti i gruppi considerati.\n\nQuesta differenza fondamentale tra CTT e IRT nell'approccio all'invarianza di gruppo rende l'IRT particolarmente adatta per applicazioni che richiedono confronti affidabili tra popolazioni diverse, come nel testing adattivo, negli studi longitudinali e nelle comparazioni tra gruppi culturali diversi.\n\n## Riflessioni Conclusive \n\nIn questo capitolo, abbiamo esplorato la progressione dei modelli IRT, partendo dal modello di Rasch fino al più flessibile modello 3PL. Ogni modello offre un equilibrio unico tra semplicità e adattabilità, consentendo di rispondere a esigenze diverse nell’ambito della misurazione psicometrica. \n\n- Il **modello di Rasch**, con i suoi vincoli rigorosi, si distingue per la sua capacità di fornire misurazioni oggettive e stabili, risultando particolarmente utile nella costruzione di strumenti di misurazione.\n- Il **modello 1PL** mantiene la semplicità del modello di Rasch ma introduce una maggiore flessibilità consentendo di variare il parametro di discriminazione a livello teorico.\n- Il **modello 2PL** aggiunge un ulteriore livello di complessità, permettendo a ogni item di avere una discriminazione specifica, migliorando l’adattamento ai dati reali.\n- Il **modello 3PL** completa questa progressione introducendo il parametro di guessing, necessario per tenere conto delle risposte corrette casuali, tipiche nei test a scelta multipla.\n\nQuesta evoluzione riflette l’importanza di adattare il modello alle caratteristiche dei dati e alle finalità dell’analisi. Abbiamo anche sottolineato l'importanza dell’**invarianza di gruppo**, una proprietà chiave che consente confronti equi tra popolazioni diverse, distinguendo l’IRT dalla Teoria Classica dei Test (CTT).\n\nIn definitiva, la scelta del modello dipende dall’obiettivo specifico dello studio e dalla complessità dei dati osservati. Il modello di Rasch offre rigore e semplicità, mentre i modelli 2PL e 3PL offrono flessibilità e precisione. Questa progressione dimostra la versatilità della IRT come framework per la misurazione psicometrica, supportando applicazioni che spaziano dalla ricerca accademica allo sviluppo di test standardizzati.\n\n## Session Info\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsessionInfo()\n#> R version 4.4.2 (2024-10-31)\n#> Platform: aarch64-apple-darwin20\n#> Running under: macOS Sequoia 15.3.2\n#> \n#> Matrix products: default\n#> BLAS:   /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRblas.0.dylib \n#> LAPACK: /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.0\n#> \n#> locale:\n#> [1] C/UTF-8/C/C/C/C\n#> \n#> time zone: Europe/Rome\n#> tzcode source: internal\n#> \n#> attached base packages:\n#> [1] grid      stats4    stats     graphics  grDevices utils     datasets \n#> [8] methods   base     \n#> \n#> other attached packages:\n#>  [1] latex2exp_0.9.6   psychotools_0.7-4 ggmirt_0.1.0      TAM_4.2-21       \n#>  [5] CDM_8.2-6         mvtnorm_1.3-3     mirt_1.44.0       lattice_0.22-6   \n#>  [9] eRm_1.0-6         ggokabeito_0.1.0  see_0.11.0        MASS_7.3-65      \n#> [13] viridis_0.6.5     viridisLite_0.4.2 ggpubr_0.6.0      ggExtra_0.10.1   \n#> [17] gridExtra_2.3     patchwork_1.3.0   bayesplot_1.11.1  semTools_0.5-6   \n#> [21] semPlot_1.1.6     lavaan_0.6-19     psych_2.4.12      scales_1.3.0     \n#> [25] markdown_1.13     knitr_1.50        lubridate_1.9.4   forcats_1.0.0    \n#> [29] stringr_1.5.1     dplyr_1.1.4       purrr_1.0.4       readr_2.1.5      \n#> [33] tidyr_1.3.1       tibble_3.2.1      ggplot2_3.5.1     tidyverse_2.0.0  \n#> [37] here_1.0.1       \n#> \n#> loaded via a namespace (and not attached):\n#>   [1] splines_4.4.2        later_1.4.1          R.oo_1.27.0         \n#>   [4] XML_3.99-0.18        rpart_4.1.24         lifecycle_1.0.4     \n#>   [7] Rdpack_2.6.3         rstatix_0.7.2        rprojroot_2.0.4     \n#>  [10] globals_0.16.3       rockchalk_1.8.157    backports_1.5.0     \n#>  [13] magrittr_2.0.3       openxlsx_4.2.8       Hmisc_5.2-3         \n#>  [16] rmarkdown_2.29       yaml_2.3.10          httpuv_1.6.15       \n#>  [19] qgraph_1.9.8         zip_2.3.2            sessioninfo_1.2.3   \n#>  [22] pbapply_1.7-2        minqa_1.2.8          multcomp_1.4-28     \n#>  [25] abind_1.4-8          audio_0.1-11         quadprog_1.5-8      \n#>  [28] R.utils_2.13.0       nnet_7.3-20          TH.data_1.1-3       \n#>  [31] sandwich_3.1-1       listenv_0.9.1        testthat_3.2.3      \n#>  [34] vegan_2.6-10         arm_1.14-4           parallelly_1.42.0   \n#>  [37] permute_0.9-7        codetools_0.2-20     tidyselect_1.2.1    \n#>  [40] farver_2.1.2         lme4_1.1-36          base64enc_0.1-3     \n#>  [43] jsonlite_1.9.1       polycor_0.8-1        progressr_0.15.1    \n#>  [46] Formula_1.2-5        survival_3.8-3       emmeans_1.10.7      \n#>  [49] tools_4.4.2          Rcpp_1.0.14          glue_1.8.0          \n#>  [52] mnormt_2.1.1         admisc_0.37          xfun_0.51           \n#>  [55] mgcv_1.9-1           withr_3.0.2          beepr_2.0           \n#>  [58] fastmap_1.2.0        boot_1.3-31          digest_0.6.37       \n#>  [61] mi_1.1               timechange_0.3.0     R6_2.6.1            \n#>  [64] mime_0.13            estimability_1.5.1   colorspace_2.1-1    \n#>  [67] gtools_3.9.5         jpeg_0.1-10          R.methodsS3_1.8.2   \n#>  [70] generics_0.1.3       data.table_1.17.0    corpcor_1.6.10      \n#>  [73] SimDesign_2.19.1     htmlwidgets_1.6.4    pkgconfig_2.0.3     \n#>  [76] sem_3.1-16           gtable_0.3.6         brio_1.1.5          \n#>  [79] htmltools_0.5.8.1    carData_3.0-5        png_0.1-8           \n#>  [82] reformulas_0.4.0     rstudioapi_0.17.1    tzdb_0.5.0          \n#>  [85] reshape2_1.4.4       coda_0.19-4.1        checkmate_2.3.2     \n#>  [88] nlme_3.1-167         nloptr_2.2.1         zoo_1.8-13          \n#>  [91] parallel_4.4.2       miniUI_0.1.1.1       foreign_0.8-88      \n#>  [94] pillar_1.10.1        vctrs_0.6.5          promises_1.3.2      \n#>  [97] car_3.1-3            OpenMx_2.21.13       xtable_1.8-4        \n#> [100] Deriv_4.1.6          cluster_2.1.8.1      dcurver_0.9.2       \n#> [103] GPArotation_2024.3-1 htmlTable_2.4.3      evaluate_1.0.3      \n#> [106] pbivnorm_0.6.0       cli_3.6.4            kutils_1.73         \n#> [109] compiler_4.4.2       rlang_1.1.5          future.apply_1.11.3 \n#> [112] ggsignif_0.6.4       fdrtool_1.2.18       plyr_1.8.9          \n#> [115] stringi_1.8.4        munsell_0.5.1        lisrelToR_0.3       \n#> [118] pacman_0.5.1         Matrix_1.7-3         hms_1.1.3           \n#> [121] glasso_1.11          future_1.34.0        shiny_1.10.0        \n#> [124] rbibutils_2.3        igraph_2.1.4         broom_1.0.7         \n#> [127] RcppParallel_5.1.10\n```\n:::\n",
    "supporting": [
      "04_1pl_2pl_3pl_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}