{
  "hash": "29834d403dc4ba87f2dbf3e6eeca1d90",
  "result": {
    "engine": "knitr",
    "markdown": "# Applicazioni della CTT {#sec-ctt-applications}\n\n**Preparazione del Notebook**\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhere::here(\"code\", \"_common.R\") |> source()\npacman::p_load(lavaan, modelsummary, foreach, ggridges, truncnorm, cmdstanr, doParallel)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nI pacchetti binari scaricati sono in\n\t/var/folders/gw/hc72by314msbfbhm58gh0fgc0000gn/T//RtmpahsC1w/downloaded_packages\n```\n\n\n:::\n:::\n\n\n\n\n## Introduzione\n\nQuesto capitolo si focalizza sull'esplorazione di diverse applicazioni della Teoria Classica dei Test (CTT). Innanzitutto, verrà analizzato il metodo per determinare il numero di item necessari al fine di ottenere un livello specifico di affidabilità. Successivamente, si approfondirà il concetto di correlazione disattenuata e si esaminerà il metodo proposto per mitigare tale disattenuazione. Infine, verrà presentato l'utilizzo del metodo di Kelly per migliorare la stima dei punteggi reali a livello individuale, e sarà esaminato come i modelli bayesiani gerarchici rappresentino un'alternativa più moderna a tale approccio.\n\n## Stimare un Cambiamento Clinicamente Significativo\n\nIn psicologia clinica, uno dei principali problemi è determinare se si sia verificato un cambiamento clinicamente significativo in un individuo. Le metodologie utilizzate per questa valutazione sono generalmente suddivise in due categorie: i metodi \"basati su ancoraggi\" e quelli \"basati sulla distribuzione\" [@blampied2022reliable].\n\nI metodi basati su ancoraggi definiscono un cambiamento clinicamente significativo come una variazione nei punteggi che corrisponde a un evento clinico rilevante. In altre parole, si considera che un cambiamento sia significativo se riflette un miglioramento o peggioramento percepito in seguito a un evento clinico importante, come ad esempio il miglioramento dopo un intervento terapeutico. I metodi basati sulla distribuzione, invece, utilizzano gli errori di misurazione psicometrica come parametro per valutare la significatività clinica del cambiamento. Uno dei primi metodi di questo tipo è stato l’indice di cambiamento affidabile, o Reliable Change Index (RCI), proposto da Jacobson e Truax. Questo indice si basa sull’errore standard della differenza (SED), che a sua volta è derivato dall'errore standard di misura (SEM). Quest'ultimo è calcolato come: \n\n$$\nSEM = s_x \\sqrt{1 - r_{xx'}},\n$$\n\ndove $s_x$ è la deviazione standard dei punteggi al pre-test e $r_{xx'}$ è la affidabilità dello strumento di misura. \n\nUn cambiamento è considerato clinicamente significativo se supera l'errore di misura intrinseco, ossia la variabilità casuale che può essere attribuita all'errore di misurazione e non a un cambiamento reale.\n\n### Calcolo del Reliable Change Index (RCI)\n\nPer comprendere come si calcola il Reliable Change Index, è utile ricordare che qualsiasi misurazione può essere scomposta in due componenti: il punteggio reale (o vero) e un componente di errore. Possiamo rappresentare qualsiasi misurazione come:\n\n$$\nX = T \\pm E,\n$$\n\ndove $X$ è il punteggio osservato, $T$ il punteggio vero e $E$ l’errore di misurazione. Se un cambiamento effettivo si è verificato nel tempo per un individuo nella dimensione catturata dalla variabile dipendente e all'interno della sensibilità dello strumento di misurazione, allora il punteggio vero al tempo $t1$ sarà diverso dal punteggio vero al tempo $t2$. Tuttavia, data la variabilità e l'errore intrinseci alle misurazioni psicologiche, è possibile che si osservi una differenza tra i punteggi $t1$ e $t2$ anche in assenza di un reale cambiamento. Pertanto, come possiamo determinare quanto debba essere grande un cambiamento osservato affinché si possa concludere che un cambiamento reale sia effettivamente avvenuto, piuttosto che semplicemente una variazione insignificante?\n\nLa derivazione dell'RCI si basa sulla distribuzione di frequenza degli errori di misurazione. La deviazione standard della distribuzione degli errori di misurazione è data dal SEM, e Jacobson e colleghi (1984) hanno utilizzato questa conoscenza di base per definire l'RCI. Tuttavia, per comprendere questa definizione, è necessario prima comprendere la distribuzione degli errori dei punteggi di differenza.\n\n### Calcolo della Differenza tra i Punteggi e la sua Distribuzione di Errore\n\nIl modo più semplice per identificare se un cambiamento si è verificato è calcolare un punteggio di differenza non nullo, rappresentato come un punteggio di cambiamento grezzo ($C$) dato dalla differenza tra il punteggio al tempo $t2$ e quello al tempo $t1$ per un individuo:\n\n$$\nC_i = X_{t1} - X_{t2},\n$$\n\ndove $C_i$ è il punteggio di cambiamento per l’individuo $i$, e $X$ rappresenta il punteggio misurato in due momenti temporali distinti $t1$ e $t2$. Poiché ogni misurazione contiene sia un punteggio vero che un errore di misurazione, il punteggio di cambiamento grezzo comprenderà il vero cambiamento più o meno un errore di misurazione. Poiché l'errore è il risultato della combinazione degli errori presenti in ciascuna misurazione, esso sarà più grande rispetto agli errori associati ai singoli punteggi.\n\nLa distribuzione degli errori dei punteggi di differenza segue anch'essa una distribuzione normale con media pari a zero ma con una deviazione standard più ampia, chiamata deviazione standard della differenza ($SD_{Diff}$), calcolata come:\n\n$$\nSD_{Diff} = \\sqrt{2 \\times SEM^2}.\n$$\n\nQuesto perché, secondo la proprietà della varianza di una differenza tra due variabili indipendenti (o scorrelate), la varianza della differenza è data dalla somma delle varianze individuali, ossia:\n\n$$\n\\sigma_{X1 - X2} = \\sigma_1^2 + \\sigma_2^2 - 2 \\cdot \\text{cov}(X1, X2).\n$$\n\nNel caso in cui le misurazioni siano indipendenti o non correlate, $\\text{cov}(X1, X2) = 0$, e quindi la deviazione standard della differenza diventa $\\sqrt{2 \\cdot SEM^2}$.\n\nAnche se i punteggi osservati prima e dopo l’intervento riflettono lo stesso individuo e sono quindi correlati nei loro \"punteggi veri\" (cioè il cambiamento reale), si considera che gli errori di misurazione associati a ciascun punteggio siano indipendenti. Questo è un presupposto comune nelle analisi psicometriche, poiché ogni volta che si ripete una misurazione su uno stesso individuo, le fonti di errore possono variare (per esempio, variazioni casuali nel modo in cui risponde al test in un determinato giorno, piccole differenze nel contesto della misurazione, ecc.).\n\n### Definizione dell'RCI\n\nJacobson e Truax (1991) hanno definito l'RCI come il punteggio di cambiamento standardizzato, ottenuto dividendo il punteggio di differenza per $SD_{Diff}$:\n\n$$\nC_i (\\text{Standardized}) = \\frac{C_i}{SD_{Diff}}.\n$$\n\nQuesta trasformazione converte il punteggio di cambiamento grezzo in unità di deviazione standard, analogamente a come uno z-score rappresenta la differenza tra un punteggio individuale e la media, standardizzata tramite la deviazione standard. Un valore di RCI clinicamente significativo suggerisce che il cambiamento osservato è sufficientemente grande da non poter essere attribuito al solo errore di misurazione.\n\n## Affidabilità e lunghezza del test\n\nL'affidabilità può essere utilizzata per determinare la lunghezza di un test. La formula di Spearman-Brown può essere adattata per calcolare il numero di item necessari al fine di raggiungere una specifica affidabilità:\n\n$$\n\\begin{equation}\np = \\frac{\\rho_p(1 - \\rho_1)}{\\rho_1(1 - \\rho_p)},\n\\end{equation}\n$$ {#eq-spearman-brown-item-number}\n\ndove $\\rho_1$ rappresenta l'affidabilità stimata di un \"item medio\", $\\rho_p$ è il livello desiderato di affidabilità complessiva del test, e $p$ è il numero di item nel test esteso.\n\nPer esempio, supponiamo che l'attendibilità di un test composto da 5 item sia 0.824, e che $\\rho_1$ sia 0.479. Possiamo chiederci quanti item debbano essere aggiunti per raggiungere un livello di affidabilità pari a 0.95.\n\nPonendo $\\rho_p$ a 0.95 e $\\rho_1$ a 0.479, in base all'equazione @eq-spearman-brown-item-number, otteniamo che:\n\n\n\n\n::: {.cell layout-align=\"center\" vscode='{\"languageId\":\"r\"}'}\n\n```{.r .cell-code}\nrho_1 <- 0.479\n(.95 * (1 - rho_1)) / (rho_1 * (1 - .95))\n#> [1] 20.7\n```\n:::\n\n\n\n\nPertanto, per ottenere un livello di affidabilità pari a 0.95 sono necessari almeno 21 item.\n\n## Attenuazione\n\n### Attenuazione e Correlazioni Disattenuate\n\nUn aspetto cruciale nell'analisi statistica riguarda il fenomeno dell'attenuazione, che si verifica quando l'incremento dell'errore di misurazione porta a una riduzione della correlazione osservata tra due variabili. Questo errore di misurazione tende a \"nascondere\" la vera associazione esistente tra le variabili, generando quello che è noto come effetto di attenuazione.\n\nLord e Novick (1967) hanno sottolineato che, nel tentativo di esplorare la relazione tra due costrutti, gli psicologi spesso ricorrono allo sviluppo di scale di misura. Se esiste una relazione lineare tra queste scale, è possibile calcolare il grado di correlazione attraverso il coefficiente di correlazione. Tuttavia, dato che le scale includono inevitabilmente un certo livello di errore, la correlazione empiricamente osservata tra di esse risulta inferiore rispetto alla correlazione \"vera\" tra i costrutti. In queste circostanze, è possibile ricorrere a formule specifiche per stimare la correlazione corretta tra i tratti latenti.\n\nSi può dimostrare che la correlazione tra i punteggi veri di due costrutti, $T_X$ e $T_Y$, può essere calcolata utilizzando la correlazione $\\rho_{XY}$ tra i punteggi osservati $X$ e $Y$, e i coefficienti di affidabilità $\\rho_{XX'}$ e $\\rho_{YY'}$ dei due test, come segue:\n\n$$\n\\begin{equation}\n\\rho(T_X, T_Y)  = \\frac{\\rho_{XY}}{\\sqrt{\\rho_{XX^\\prime} \\rho_{YY^\\prime}}}.\n\\end{equation}\n$$(eq-3-9-6)\n\nAnalogamente, la correlazione tra i punteggi osservati di un test e i punteggi veri di un secondo test può essere espressa attraverso la correlazione tra i punteggi osservati dei due test e il coefficiente di affidabilità del secondo test:\n\n$$\n\\begin{equation}\n\\rho(X, T_Y)  = \\frac{\\rho_{XY}}{\\sqrt{\\rho_{YY^\\prime}}}.\n\\end{equation}\n$$(eq-3-9-7)\n\nQueste equazioni forniscono gli strumenti per calcolare le correlazioni disattenuate secondo la Teoria Classica dei Test (CTT).\n\nIl calcolo degli intervalli di confidenza per la correlazione corretta richiede un approccio che tenga conto dell'attenuazione dell'affidabilità. Applicando la formula di disattenuazione agli estremi dell'intervallo di confidenza osservato, possiamo ottenere stime più precise degli intervalli di confidenza per la correlazione tra i punteggi veri.\n\nPer fare un esempio, supponiamo di avere una correlazione osservata di 0.5 tra due misure, con affidabilità di 0.7 per la prima misura e 0.8 per la seconda misura. Vogliamo calcolare la correlazione disattenuata e il relativo intervallo di confidenza.\n\n\n\n\n::: {.cell layout-align=\"center\" vscode='{\"languageId\":\"r\"}'}\n\n```{.r .cell-code}\n# Parametri\nr_osservata <- 0.5\nrho_X <- 0.7\nrho_Y <- 0.8\n\n# Calcolo della correlazione disattenuata\nr_corretta <- r_osservata / sqrt(rho_X * rho_Y)\n\n# Stampa della correlazione disattenuata\nprint(paste(\"Correlazione disattenuata:\", r_corretta))\n#> [1] \"Correlazione disattenuata: 0.668153104781061\"\n\n# Calcolo approssimativo dell'intervallo di confidenza (per semplificazione)\n# NOTA: Questo è un esempio semplificato e non riflette il calcolo preciso degli intervalli di confidenza.\nCI_lower_observed <- 0.4 # Limite inferiore osservato\nCI_upper_observed <- 0.6 # Limite superiore osservato\n\nCI_lower_corrected <- CI_lower_observed / sqrt(rho_X * rho_Y)\nCI_upper_corrected <- CI_upper_observed / sqrt(rho_X * rho_Y)\n\n# Stampa dell'intervallo di confidenza corretto\nprint(paste(\"Intervallo di confidenza corretto: da\", CI_lower_corrected, \"a\", CI_upper_corrected))\n#> [1] \"Intervallo di confidenza corretto: da 0.534522483824849 a 0.801783725737273\"\n```\n:::\n\n\n\n\n### L'impiego delle Correlazioni Disattenuate\n\nL'uso delle correlazioni disattenuate risale al 1904 con Spearman, che le applicò in uno studio in cui $X$ misurava la discriminazione dell'altezza del suono e $Y$ l'intelligenza valutata da un insegnante. La correlazione tra queste due misure era $\\hat{\\rho}_{XY} = 0.38$, con affidabilità di $\\hat{\\rho}_{XX'} = 0.25$ e $\\hat{\\rho}_{YY'} = 0.55$. Utilizzando le formule sopra citate, la correlazione predetta tra i punteggi veri di discriminazione del suono e l'intelligenza risultava essere $\\hat{\\rho}(X, T_Y) = 0.76$, mentre tra i punteggi veri dei due costrutti era $\\hat{\\rho}(T_X, T_Y) = 1.025$.\n\nQuesto esempio evidenzia come l'uso delle correlazioni disattenuate possa portare a stime eccessive, una problematica già rilevata nell'interazione tra Spearman e Karl Pearson. Spearman, attraverso l'applicazione della sua formula, sottolineò come le correlazioni empiriche basse proposte da Pearson potessero essere sottostimate a causa dell'errore di misurazione. Tuttavia, Pearson non accolse queste osservazioni, rimanendo scettico riguardo alla possibilità che la formula di Spearman generasse correlazioni superiori a 1 e rigettando l'idea di quantità non osservabili.\n\nNonostante queste controversie, Spearman proseguì nello studio delle variabili psicologiche, trovando in numerosi casi che le correlazioni disattenuate si avvicinavano all'unità, suggerendo un'associazione stretta tra variabili indicative dello stesso fenomeno. Queste osservazioni lo portarono a sviluppare ulteriormente l'analisi fattoriale.\n\nMcDonald (1999) avverte sull'utilizzo delle correlazioni disattenuate, evidenziando la necessità di cautela. Propone come alternativa più affidabile l'uso di modelli di equazioni strutturali per calcolare le correlazioni tra variabili latenti, ovvero quelle non influenzate da errori di misurazione, consentendo un'esplorazione diretta e più accurata delle ipotesi, inclusa la correlazione tra variabili latenti.\n\n## Usare l'Affidabilità per Migliorare l'Inferenza a Livello Individuale\n\nUn altro uso importante dell'affidabilità è quello che ci consente di migliorare la nostra inferenza sui punteggi veri a livello individuale.\n\nKelley ha dimostrato – già nel 1920 (vedi Kelley, 1947) – che possiamo stimare i punteggi veri per ciascun individuo, regredendo i punteggi osservati sulla stima dell'affidabilità:\n\n$$ \\hat{T} = \\bar{X} + r_{xx'}(X - \\bar{X}). $$\n\nQui, $\\bar{X}$ è la media dei punteggi osservati su tutti i soggetti, data da:\n\n$$ \\bar{X} = \\frac{1}{N} \\sum_{i=1}^{N} X_i. $$\n\nIntuitivamente, il punteggio vero per ciascun soggetto è stimato avvicinando il loro punteggio osservato verso la media dei punteggi a livello di gruppo in proporzione all'affidabilità della stima a livello individuale.\n\nIn aggiunta alla sua teoria che i punteggi osservati tendono ad essere regolati verso la media del gruppo quando si stima il vero punteggio, Kelley ha evidenziato come l'errore standard della stima del vero punteggio sia ridotto secondo la formula:\n\n$$\n\\sigma_{\\hat{T}} = \\sigma_X \\sqrt{\\rho_{XX^\\prime} (1 -\\rho_{XX^\\prime})}.\n$$\n\nQui, $\\sigma_{\\hat{T}}$ rappresenta l'errore standard della stima del vero punteggio, $\\sigma_X$ è la deviazione standard dei punteggi osservati, e $\\rho_{XX^\\prime}$ indica il coefficiente di affidabilità tra i punteggi osservati e quelli veri. Questo errore standard per le stime dei punteggi veri è inferiore rispetto all'errore standard dei punteggi osservati, espresso come:\n\n$$\nSE_{X} = \\sigma_{X} \\sqrt{1 - \\rho_{XX'}}.\n$$\n\nIl confronto tra le due formule rivela che l'errore standard della stima del vero punteggio include un fattore aggiuntivo, $\\rho_{XX'}$, che rappresenta il coefficiente di affidabilità. Questo evidenzia l'importanza del coefficiente di affidabilità nell'influenzare la precisione della stima del vero punteggio: un alto coefficiente di affidabilità contribuisce a ridurre l'errore standard della stima, migliorando così la precisione della stima del vero punteggio.\n\nLe equazioni di Kelley, scoperte nel 1920, anticipano di molti anni i principi alla base degli stimatori di James-Stein, che analogamente aggiustano le stime individuali avvicinandole alla media del gruppo. Questa affinità storica evidenzia un precedente significativo alla comprensione moderna di come le stime possano essere migliorate mediante l'incorporazione di informazioni aggiuntive.\n\nLa relazione tra le equazioni di Kelley e i concetti bayesiani offre una prospettiva ancora più profonda. Assumendo che i punteggi veri seguano una distribuzione a priori normale e che esista una distribuzione normale dei punteggi veri intorno ai punteggi osservati, l'approccio bayesiano empirico genera medie posteriori che corrispondono alle stime di Kelley dei punteggi veri. Questa equivalenza, come discussa da de Gruijter e van der Kamp nel 2008, stabilisce un ponte concettuale tra la psicometria classica e l'inferenza bayesiana, sottolineando come l'incorporazione di presupposti a priori possa affinare le nostre stime.\n\nQuesta connessione è ulteriormente rafforzata dall'uso di tecniche simili alla stima bayesiana empirica nei software di modellazione multilivello, come ad esempio il pacchetto `lmer` in R. Questi software si avvalgono della potenza dell'inferenza bayesiana per integrare informazioni di gruppo, migliorando così la precisione delle inferenze a livello individuale. La pratica di utilizzare informazioni a livello di gruppo per affinare le stime individuali non solo ha radici storiche profonde ma continua a essere una componente essenziale nell'evoluzione delle tecniche statistiche, dimostrando il suo valore nell'arricchire l'accuratezza e l'affidabilità delle inferenze statistiche.\n\nPer illustrare in modo pratico come avviene la stima dei punteggi veri, ossia il processo di pooling, eseguiremo una simulazione basata sul codice R di Nathaniel Haines. Questa simulazione genera dati seguendo una distribuzione binomiale per 20 soggetti, con una probabilità media di successo di 0.7. La simulazione considera tre diversi set di item: 10, 30 e 100, al fine di esaminare come le variazioni nel numero di item influenzino l'affidabilità ottenuta e, di conseguenza, gli effetti del pooling.\n\nIl codice inizia definendo il numero di soggetti e la varietà delle dimensioni degli item. Successivamente, genera un campione casuale di \"punteggi veri\" intorno a 0.7 per ogni soggetto. Viene poi definita una funzione per stimare l'errore standard della misurazione (al quadrato), basata sulla probabilità di successo per ogni item.\n\nPer ogni set di item, il codice simula i dati osservati per ogni soggetto utilizzando il suo \"punteggio vero\". Calcola quindi la media del gruppo per i punteggi osservati, la affidabilità, e l'errore standard di misurazione, utilizzando l'approccio basato sulla varianza. Infine, stima i punteggi veri e gli errori standard associati sia per i punteggi osservati sia per quelli stimati.\n\nI risultati della simulazione vengono visualizzati in un grafico, che confronta i punteggi veri, osservati e stimati per ogni soggetto, evidenziando come la precisione della stima vari in funzione del numero di item. Il grafico include anche intervalli di confidenza al 95% per i punteggi osservati e stimati, e una linea orizzontale che rappresenta la media del gruppo per i punteggi osservati, offrendo una rappresentazione visiva dell'efficacia del processo di pooling nel recuperare i punteggi veri a partire da dati osservati affetti da errore di misurazione.\n\n\n\n\n::: {.cell layout-align=\"center\" vscode='{\"languageId\":\"r\"}'}\n\n```{.r .cell-code}\nset.seed(43202)\n\n# Number of subjects and items\nn_subj <- 20\nn_items <- c(10, 30, 100)\n\n# Random sample of \"true\" scores around .7\ntheta <- rnorm(n_subj, .7, .1)\n\n# Estimate standard error of measurement (squared)\nest_se2 <- function(x) {\n    # Success and failure probability\n    n <- length(x)\n    p <- mean(x)\n    q <- 1 - p\n\n    sig2_ep_i <- (p * q) / (n - 1)\n\n    return(sig2_ep_i)\n}\n\n# Estimate observed and true score\ndis_dat <- foreach(i = seq_along(n_items), .combine = \"rbind\") %do% {\n    # Generate observed data for each subject using \"true\" score\n    X_all <- foreach(t = seq_along(theta), .combine = \"rbind\") %do% {\n        rbinom(n_items[i], 1, prob = theta[t])\n    }\n\n    # group average observed score\n    X_bar <- mean(rowMeans(X_all))\n\n    # Reliability\n    X <- rowMeans(X_all)\n\n    # Standard arror of measurement approach\n    sig2_ep <- mean(apply(X_all, 1, est_se2))\n    sig2_X <- var(X)\n    rho <- 1 - (sig2_ep / sig2_X)\n\n    foreach(t = seq_along(theta), .combine = \"rbind\") %do% {\n        # Using observed scores from parallel form 1\n        X_obs <- X_all[t, ]\n        X_i <- mean(X_obs)\n\n        data.frame(\n            subj_num = t,\n            n_items = n_items[i],\n            theta = theta[t],\n            rho = rho,\n            X = X_i,\n            se_obs = sd(X) * sqrt(1 - rho),\n            se_hat = sd(X) * sqrt(1 - rho) * sqrt(rho),\n            theta_hat = (1 - rho) * X_bar + rho * X_i\n        )\n    }\n}\n\n# Plot true, observed, and estimated true scores\ndis_dat %>%\n    mutate(subj_num = reorder(subj_num, theta)) %>%\n    ggplot(aes(x = subj_num, y = theta)) +\n    geom_point(color = I(\"black\")) +\n    geom_point(aes(x = subj_num, y = X),\n        color = I(\"#DCBCBC\"),\n        position = position_jitter(width = .2, height = 0, seed = 1)\n    ) +\n    geom_linerange(\n        aes(\n            x = subj_num,\n            ymin = X - 1.96 * se_obs,\n            ymax = X + 1.96 * se_obs\n        ),\n        color = I(\"#DCBCBC\"),\n        position = position_jitter(width = .2, height = 0, seed = 1)\n    ) +\n    geom_point(aes(x = subj_num, y = theta_hat),\n        color = I(\"#8F2727\"),\n        position = position_jitter(width = .2, height = 0, seed = 2)\n    ) +\n    geom_linerange(\n        aes(\n            x = subj_num,\n            ymin = theta_hat - 1.96 * se_hat,\n            ymax = theta_hat + 1.96 * se_hat\n        ),\n        color = I(\"#8F2727\"),\n        position = position_jitter(width = .2, height = 0, seed = 2)\n    ) +\n    geom_hline(yintercept = X_bar, linetype = 2, color = I(\"gray\")) +\n    annotate(\"text\",\n        x = 15, y = .4, label = expression(\"True\" ~ theta[i]),\n        color = \"black\", size = 5\n    ) +\n    annotate(\"text\",\n        x = 15, y = .3, label = expression(\"Obs\" ~ X[i]),\n        color = \"#DCBCBC\", size = 5\n    ) +\n    annotate(\"text\",\n        x = 15, y = .2, label = expression(\"Est\" ~ hat(theta)[i]),\n        color = \"#8F2727\", size = 5\n    ) +\n    facet_wrap(c(\"n_items\"), nrow = 1) +\n    ggtitle(\"Regression-Based True Score Estimates\") +\n    xlab(\"Subject\") +\n    ylab(\"Value\") +\n    theme_minimal(base_size = 15) +\n    theme(\n        panel.grid = element_blank(),\n        axis.text.x.bottom = element_blank()\n    )\n```\n\n::: {.cell-output-display}\n![](06_ctt_applications_files/figure-html/unnamed-chunk-4-1.png){fig-align='center' width=70%}\n:::\n:::\n\n\n\n\nSi notino tre risultati di questa simulazione: \n\n1. le stime puntuali basate sulla regressione di Kelley (i punti neri nel grafico) risultano più vicine alla media a livello di gruppo (rappresentata dalla linea tratteggiata grigia orizzontale) di quanto lo siano le stime individuali \"non corrette\" (punti grigi);\n2. questo effetto di \"pooling\" è tanto maggiore quanto minore è l'attendibilità (in questa simulazione l'attendibilità è stata manipolata variando il numero di item);\n3. gli intervalli di confidenza per i punteggi veri stimati sono più stretti rispetto a quelli dei punteggi osservati.\n\n### Approccio Bayesiano\n\nNella seguente simulazione mostreremo come i risultati raggiunti con la regressione di Kelley possano essere replicati se i dati vengono analizzati con un modello gerarchico bayesiano.\n\nQuando si analizzano dati provenienti da questionari con risposte dicotomiche (ad esempio, vero/falso o corretto/errato), è possibile applicare la distribuzione di Bernoulli. In questo contesto, ogni risposta data a un item del questionario può essere vista come il risultato di un esperimento di Bernoulli. Se indichiamo con $X$ una variabile casuale che segue tale distribuzione, la probabilità di ottenere un successo (ad esempio, una risposta corretta) è espressa come:\n\n$$\n\\Pr(X=1) = p, \\quad \\text{e quindi} \\quad \\Pr(X=0) = 1 - p = q,\n$$\n\ndove $p$ indica la probabilità di successo e $q$ quella di insuccesso.\n\nIntroduciamo il modello di Bernoulli tramite l'equazione logistica:\n\n$$\np = \\frac{1}{1 + e^{-\\theta}}.\n$$\n\nQuesta formula ci permette di modellare $p$ in termini di $\\theta$, un parametro che riflette una caratteristica o \"abilità\" dell'individuo. Il modello logistico assicura che $p$, la probabilità di successo, sia sempre compresa nell'intervallo $[0, 1]$. Il parametro $\\theta$ viene definito come:\n\n$$\n\\theta = \\log\\left(\\frac{p}{1-p}\\right),\n$$\n\ne può variare tra $-\\infty$ e $+\\infty$. Attraverso la trasformazione logistica, $\\theta$ viene mappato in un valore di $p$ che rispetta i limiti di una probabilità. Questa funzione di collegamento permette di interpretare il legame tra $\\theta$ e $p$.\n\nIl modello descritto sopra può essere considerato una forma estremamente semplificata della Teoria della Risposta all'Item (IRT), dove ogni persona è caratterizzata da un unico parametro di abilità ($\\theta$), e tutti gli item del test sono assunti avere uguale difficoltà e capacità di discriminazione, fissate convenzionalmente a 1.\n\nIl nostro obiettivo principale nell'analisi dei dati è quindi stimare il parametro $\\theta$ per ogni individuo. La relazione tra $\\theta$ e $p$ è fondamentale: $\\theta$ determina il valore di $p$ attraverso la funzione logistica, che trasforma i valori di $\\theta$ in probabilità $p$ comprese tra 0 e 1. La stima di $\\theta$ ci fornisce, di conseguenza, una misura della probabilità di successo di un individuo in risposta agli item del questionario.\n\nPer approfondire la nostra comprensione su come emergono le risposte osservate, è fondamentale definire la modalità con cui i parametri $\\theta$ vengono generati per ogni individuo. Similmente a quanto avviene nella teoria classica dei test, dove si presume l'esistenza di una distribuzione di campionamento a livello di popolazione, nell'ambito della modellazione generativa bayesiana si postula una distribuzione generativa per il gruppo. In termini pratici, possiamo ipotizzare che i parametri $\\theta$ individuali derivino da una distribuzione normale standardizzata:\n\n$$\n\\theta \\sim \\mathcal{N}(0, 1)\n$$\n\nNel contesto bayesiano, questa distribuzione di gruppo viene comunemente identificata come una distribuzione a priori per $\\theta$. In alternativa, possiamo dedurre questi parametri direttamente dai dati:\n\n$$\n\\theta \\sim \\mathcal{N}(\\mu, \\sigma)\n$$\n\nDi conseguenza, si introduce un'ipotesi generativa riguardante i parametri di media $\\mu$ e deviazione standard $\\sigma$ del gruppo, che potrebbero essere descritti, in termini bayesiani tradizionali, come a priori del gruppo. Nel nostro esempio, supponiamo $\\mu = 0$ e $\\sigma \\sim \\text{HalfNormal}(1)$, dove $\\text{HalfNormal}(1)$ rappresenta una distribuzione normale limitata ai valori positivi, coerente con il principio che le deviazioni standard debbano essere positive. \n\nQuesto approccio introduce un modello gerarchico: durante l'adattamento del modello, i parametri individuali influenzano quelli di gruppo, che a loro volta modellano nuovamente quelli individuali. Analogamente alle stime dei punteggi \"veri\" ottenuti tramite regressione nella teoria classica dei test, i nostri parametri individuali verranno regolati (\"pooled\") verso la media di gruppo, portando a una riduzione degli intervalli di incertezza per le stime individuali.\n\nPer facilitare la comprensione di come queste assunzioni generative si traducano in pratica, eseguiamo la seguente simulazione.\n\n\n\n\n::: {.cell layout-align=\"center\" vscode='{\"languageId\":\"r\"}'}\n\n```{.r .cell-code}\nfile <- file.path(\"hbern.stan\")\n```\n:::\n\n::: {.cell layout-align=\"center\" tags='hide-output' vscode='{\"languageId\":\"r\"}'}\n\n```{.r .cell-code}\nmod <- cmdstan_model(file)\n```\n:::\n\n::: {.cell layout-align=\"center\" vscode='{\"languageId\":\"r\"}'}\n\n```{.r .cell-code}\nmod$print()\n#> data {\n#>   int<lower=0> N;      // Number of subjects\n#>   int<lower=0> N_items; // Number of timepoints\n#>   array[N, N_items] int Y; // Binary responses for each subject and item\n#> }\n#> \n#> parameters {\n#>   real<lower=0> sigma_theta; // SD of individual effects\n#>   real mu_theta; // Mean of individual effects\n#>   \n#>   vector[N] theta_pr; // Non-centered individual-level parameters\n#> }\n#> \n#> transformed parameters {\n#>   vector[N] theta = mu_theta + sigma_theta * theta_pr; // Individual-level effects\n#> }\n#> \n#> model {\n#>   // Priors\n#>   mu_theta ~ normal(0, 1);\n#>   sigma_theta ~ normal(0, 1);\n#>   theta_pr ~ normal(0, 1);\n#>   \n#>   // Likelihood\n#>   for (i in 1:N) {\n#>     for (j in 1:N_items) {\n#>       Y[i, j] ~ bernoulli_logit(theta[i]);\n#>     }\n#>   }\n#> }\n#> \n#> generated quantities {\n#>   array[N] real p; // Success probability estimate for each individual\n#>   \n#>   for (i in 1:N) {\n#>     p[i] = inv_logit(theta[i]);\n#>   }\n#> }\n```\n:::\n\n\n\n\nIl codice Stan presentato adotta una parametrizzazione non centrata (*non-centered parameterization*) per la parte di modello a livello di gruppo, una scelta motivata per migliorare l'efficienza computazionale e facilitare la convergenza degli algoritmi di stima, come il campionamento Hamiltoniano Monte Carlo (HMC) usato da Stan. Questa scelta di design è matematicamente equivalente al modello generativo descritto dalle equazioni precedenti, pur offrendo vantaggi pratici significativi in fase di implementazione.\n\nLa parametrizzazione non centrata è una strategia avanzata nella modellazione bayesiana, specialmente utile nei modelli gerarchici o multilivello. Essa differisce dalla parametrizzazione centrata, nella quale i parametri di gruppo sono direttamente definiti dai parametri individuali. Invece, con la parametrizzazione non centrata, i parametri individuali sono inizialmente espressi come variazioni indipendenti rispetto alla media e deviazione standard di gruppo, per poi essere trasformati.\n\nImplementazione nel codice Stan:\n\n1. **Definizione dei Parametri:**\n   - `sigma_theta` denota la deviazione standard degli effetti individuali, indicando la variabilità dei parametri $\\theta$ a livello personale.\n   - `mu_theta` rappresenta la media degli effetti individuali.\n   - `theta_pr` corrisponde ai parametri individuali nella forma non centrata, esprimendo le deviazioni rispetto alla media di gruppo in unità standardizzate.\n\n2. **Trasformazione dei Parametri:**\n   - Gli effetti individuali effettivi (`theta`) sono ottenuti trasformando `theta_pr` per allinearli attorno a `mu_theta` e adattarli alla scala definita da `sigma_theta`. Questo processo è sintetizzato dall'equazione `theta = mu_theta + sigma_theta * theta_pr`, che trasla e scala `theta_pr` per ottenere valori centrati e proporzionati correttamente.\n\n3. **Applicazione nel Modello:**\n   - All'interno del modello, sia `mu_theta` che `sigma_theta` sono sottoposti a priori normali (`normal(0, 1)`), presupponendo una distribuzione iniziale per questi parametri a livello di gruppo. Anche `theta_pr` è assoggettato a una distribuzione normale standard come priori, rispecchiando l'approccio di considerare le variazioni in termini standardizzati.\n   - La verosimiglianza del modello è calcolata usando una distribuzione di Bernoulli con una funzione di collegamento logit, basata sui valori di `theta` trasformati, per analizzare le risposte binarie `Y` fornite da ogni soggetto per ogni item.\n\nAttraverso questa struttura, il modello mira a una stima più stabile e accurata dei parametri, beneficiando della maggiore efficienza computazionale e della riduzione dei problemi di convergenza che spesso accompagnano la modellazione bayesiana gerarchica.\n\nSimuliamo i dati di un singolo soggetto.\n\n\n\n\n::: {.cell layout-align=\"center\" vscode='{\"languageId\":\"r\"}'}\n\n```{.r .cell-code}\n# Initialize parameters for a single subject\nn_subj <- 1\nn_items <- 30 # Example with 30 items for simplicity\n\n# Generate \"true\" theta for the subject\ntheta <- rnorm(n_subj, .7, .1)\n\n# Generate observed data for the subject using \"true\" theta\nY <- rbinom(n_items, 1, prob = theta)\n```\n:::\n\n\n\n\nAdattiamo il modello gerarchico bayesiano ai dati.\n\n\n\n\n::: {.cell layout-align=\"center\" tags='hide-output' vscode='{\"languageId\":\"r\"}'}\n\n```{.r .cell-code}\nfit_bernoulli <- mod$sample(\n    data = list(\n        N = n_subj,\n        N_items = n_items,\n        Y = matrix(Y, nrow = 1) # Ensure Y is a matrix even for a single subject\n    ),\n    iter_sampling = 2500,\n    iter_warmup = 500,\n    chains = 4,\n    parallel_chains = 4,\n    seed = 43202\n)\n#> Running MCMC with 4 parallel chains...\n#> \n#> Chain 1 Iteration:    1 / 3000 [  0%]  (Warmup) \n#> Chain 1 Iteration:  100 / 3000 [  3%]  (Warmup) \n#> Chain 1 Iteration:  200 / 3000 [  6%]  (Warmup) \n#> Chain 1 Iteration:  300 / 3000 [ 10%]  (Warmup) \n#> Chain 1 Iteration:  400 / 3000 [ 13%]  (Warmup) \n#> Chain 1 Iteration:  500 / 3000 [ 16%]  (Warmup) \n#> Chain 1 Iteration:  501 / 3000 [ 16%]  (Sampling) \n#> Chain 1 Iteration:  600 / 3000 [ 20%]  (Sampling) \n#> Chain 1 Iteration:  700 / 3000 [ 23%]  (Sampling) \n#> Chain 1 Iteration:  800 / 3000 [ 26%]  (Sampling) \n#> Chain 1 Iteration:  900 / 3000 [ 30%]  (Sampling) \n#> Chain 1 Iteration: 1000 / 3000 [ 33%]  (Sampling) \n#> Chain 1 Iteration: 1100 / 3000 [ 36%]  (Sampling) \n#> Chain 1 Iteration: 1200 / 3000 [ 40%]  (Sampling) \n#> Chain 1 Iteration: 1300 / 3000 [ 43%]  (Sampling) \n#> Chain 1 Iteration: 1400 / 3000 [ 46%]  (Sampling) \n#> Chain 1 Iteration: 1500 / 3000 [ 50%]  (Sampling) \n#> Chain 1 Iteration: 1600 / 3000 [ 53%]  (Sampling) \n#> Chain 1 Iteration: 1700 / 3000 [ 56%]  (Sampling) \n#> Chain 1 Iteration: 1800 / 3000 [ 60%]  (Sampling) \n#> Chain 1 Iteration: 1900 / 3000 [ 63%]  (Sampling) \n#> Chain 1 Iteration: 2000 / 3000 [ 66%]  (Sampling) \n#> Chain 1 Iteration: 2100 / 3000 [ 70%]  (Sampling) \n#> Chain 1 Iteration: 2200 / 3000 [ 73%]  (Sampling) \n#> Chain 1 Iteration: 2300 / 3000 [ 76%]  (Sampling) \n#> Chain 1 Iteration: 2400 / 3000 [ 80%]  (Sampling) \n#> Chain 1 Iteration: 2500 / 3000 [ 83%]  (Sampling) \n#> Chain 1 Iteration: 2600 / 3000 [ 86%]  (Sampling) \n#> Chain 1 Iteration: 2700 / 3000 [ 90%]  (Sampling) \n#> Chain 1 Iteration: 2800 / 3000 [ 93%]  (Sampling) \n#> Chain 1 Iteration: 2900 / 3000 [ 96%]  (Sampling) \n#> Chain 1 Iteration: 3000 / 3000 [100%]  (Sampling) \n#> Chain 2 Iteration:    1 / 3000 [  0%]  (Warmup) \n#> Chain 2 Iteration:  100 / 3000 [  3%]  (Warmup) \n#> Chain 2 Iteration:  200 / 3000 [  6%]  (Warmup) \n#> Chain 2 Iteration:  300 / 3000 [ 10%]  (Warmup) \n#> Chain 2 Iteration:  400 / 3000 [ 13%]  (Warmup) \n#> Chain 2 Iteration:  500 / 3000 [ 16%]  (Warmup) \n#> Chain 2 Iteration:  501 / 3000 [ 16%]  (Sampling) \n#> Chain 2 Iteration:  600 / 3000 [ 20%]  (Sampling) \n#> Chain 2 Iteration:  700 / 3000 [ 23%]  (Sampling) \n#> Chain 2 Iteration:  800 / 3000 [ 26%]  (Sampling) \n#> Chain 2 Iteration:  900 / 3000 [ 30%]  (Sampling) \n#> Chain 2 Iteration: 1000 / 3000 [ 33%]  (Sampling) \n#> Chain 2 Iteration: 1100 / 3000 [ 36%]  (Sampling) \n#> Chain 2 Iteration: 1200 / 3000 [ 40%]  (Sampling) \n#> Chain 2 Iteration: 1300 / 3000 [ 43%]  (Sampling) \n#> Chain 2 Iteration: 1400 / 3000 [ 46%]  (Sampling) \n#> Chain 2 Iteration: 1500 / 3000 [ 50%]  (Sampling) \n#> Chain 2 Iteration: 1600 / 3000 [ 53%]  (Sampling) \n#> Chain 2 Iteration: 1700 / 3000 [ 56%]  (Sampling) \n#> Chain 2 Iteration: 1800 / 3000 [ 60%]  (Sampling) \n#> Chain 2 Iteration: 1900 / 3000 [ 63%]  (Sampling) \n#> Chain 2 Iteration: 2000 / 3000 [ 66%]  (Sampling) \n#> Chain 2 Iteration: 2100 / 3000 [ 70%]  (Sampling) \n#> Chain 2 Iteration: 2200 / 3000 [ 73%]  (Sampling) \n#> Chain 2 Iteration: 2300 / 3000 [ 76%]  (Sampling) \n#> Chain 2 Iteration: 2400 / 3000 [ 80%]  (Sampling) \n#> Chain 2 Iteration: 2500 / 3000 [ 83%]  (Sampling) \n#> Chain 2 Iteration: 2600 / 3000 [ 86%]  (Sampling) \n#> Chain 2 Iteration: 2700 / 3000 [ 90%]  (Sampling) \n#> Chain 2 Iteration: 2800 / 3000 [ 93%]  (Sampling) \n#> Chain 2 Iteration: 2900 / 3000 [ 96%]  (Sampling) \n#> Chain 2 Iteration: 3000 / 3000 [100%]  (Sampling) \n#> Chain 3 Iteration:    1 / 3000 [  0%]  (Warmup) \n#> Chain 3 Iteration:  100 / 3000 [  3%]  (Warmup) \n#> Chain 3 Iteration:  200 / 3000 [  6%]  (Warmup) \n#> Chain 3 Iteration:  300 / 3000 [ 10%]  (Warmup) \n#> Chain 3 Iteration:  400 / 3000 [ 13%]  (Warmup) \n#> Chain 3 Iteration:  500 / 3000 [ 16%]  (Warmup) \n#> Chain 3 Iteration:  501 / 3000 [ 16%]  (Sampling) \n#> Chain 3 Iteration:  600 / 3000 [ 20%]  (Sampling) \n#> Chain 3 Iteration:  700 / 3000 [ 23%]  (Sampling) \n#> Chain 3 Iteration:  800 / 3000 [ 26%]  (Sampling) \n#> Chain 3 Iteration:  900 / 3000 [ 30%]  (Sampling) \n#> Chain 3 Iteration: 1000 / 3000 [ 33%]  (Sampling) \n#> Chain 3 Iteration: 1100 / 3000 [ 36%]  (Sampling) \n#> Chain 3 Iteration: 1200 / 3000 [ 40%]  (Sampling) \n#> Chain 3 Iteration: 1300 / 3000 [ 43%]  (Sampling) \n#> Chain 3 Iteration: 1400 / 3000 [ 46%]  (Sampling) \n#> Chain 3 Iteration: 1500 / 3000 [ 50%]  (Sampling) \n#> Chain 3 Iteration: 1600 / 3000 [ 53%]  (Sampling) \n#> Chain 3 Iteration: 1700 / 3000 [ 56%]  (Sampling) \n#> Chain 3 Iteration: 1800 / 3000 [ 60%]  (Sampling) \n#> Chain 3 Iteration: 1900 / 3000 [ 63%]  (Sampling) \n#> Chain 3 Iteration: 2000 / 3000 [ 66%]  (Sampling) \n#> Chain 3 Iteration: 2100 / 3000 [ 70%]  (Sampling) \n#> Chain 3 Iteration: 2200 / 3000 [ 73%]  (Sampling) \n#> Chain 3 Iteration: 2300 / 3000 [ 76%]  (Sampling) \n#> Chain 3 Iteration: 2400 / 3000 [ 80%]  (Sampling) \n#> Chain 3 Iteration: 2500 / 3000 [ 83%]  (Sampling) \n#> Chain 3 Iteration: 2600 / 3000 [ 86%]  (Sampling) \n#> Chain 3 Iteration: 2700 / 3000 [ 90%]  (Sampling) \n#> Chain 3 Iteration: 2800 / 3000 [ 93%]  (Sampling) \n#> Chain 3 Iteration: 2900 / 3000 [ 96%]  (Sampling) \n#> Chain 3 Iteration: 3000 / 3000 [100%]  (Sampling) \n#> Chain 4 Iteration:    1 / 3000 [  0%]  (Warmup) \n#> Chain 4 Iteration:  100 / 3000 [  3%]  (Warmup) \n#> Chain 4 Iteration:  200 / 3000 [  6%]  (Warmup) \n#> Chain 4 Iteration:  300 / 3000 [ 10%]  (Warmup) \n#> Chain 4 Iteration:  400 / 3000 [ 13%]  (Warmup) \n#> Chain 4 Iteration:  500 / 3000 [ 16%]  (Warmup) \n#> Chain 4 Iteration:  501 / 3000 [ 16%]  (Sampling) \n#> Chain 4 Iteration:  600 / 3000 [ 20%]  (Sampling) \n#> Chain 4 Iteration:  700 / 3000 [ 23%]  (Sampling) \n#> Chain 4 Iteration:  800 / 3000 [ 26%]  (Sampling) \n#> Chain 4 Iteration:  900 / 3000 [ 30%]  (Sampling) \n#> Chain 4 Iteration: 1000 / 3000 [ 33%]  (Sampling) \n#> Chain 4 Iteration: 1100 / 3000 [ 36%]  (Sampling) \n#> Chain 4 Iteration: 1200 / 3000 [ 40%]  (Sampling) \n#> Chain 4 Iteration: 1300 / 3000 [ 43%]  (Sampling) \n#> Chain 4 Iteration: 1400 / 3000 [ 46%]  (Sampling) \n#> Chain 4 Iteration: 1500 / 3000 [ 50%]  (Sampling) \n#> Chain 4 Iteration: 1600 / 3000 [ 53%]  (Sampling) \n#> Chain 4 Iteration: 1700 / 3000 [ 56%]  (Sampling) \n#> Chain 4 Iteration: 1800 / 3000 [ 60%]  (Sampling) \n#> Chain 4 Iteration: 1900 / 3000 [ 63%]  (Sampling) \n#> Chain 4 Iteration: 2000 / 3000 [ 66%]  (Sampling) \n#> Chain 4 Iteration: 2100 / 3000 [ 70%]  (Sampling) \n#> Chain 4 Iteration: 2200 / 3000 [ 73%]  (Sampling) \n#> Chain 4 Iteration: 2300 / 3000 [ 76%]  (Sampling) \n#> Chain 4 Iteration: 2400 / 3000 [ 80%]  (Sampling) \n#> Chain 4 Iteration: 2500 / 3000 [ 83%]  (Sampling) \n#> Chain 4 Iteration: 2600 / 3000 [ 86%]  (Sampling) \n#> Chain 4 Iteration: 2700 / 3000 [ 90%]  (Sampling) \n#> Chain 4 Iteration: 2800 / 3000 [ 93%]  (Sampling) \n#> Chain 4 Iteration: 2900 / 3000 [ 96%]  (Sampling) \n#> Chain 4 Iteration: 3000 / 3000 [100%]  (Sampling) \n#> Chain 1 finished in 0.1 seconds.\n#> Chain 2 finished in 0.1 seconds.\n#> Chain 3 finished in 0.1 seconds.\n#> Chain 4 finished in 0.1 seconds.\n#> \n#> All 4 chains finished successfully.\n#> Mean chain execution time: 0.1 seconds.\n#> Total execution time: 0.2 seconds.\n```\n:::\n\n\n\n\nCalcoliamo la media a posteriori di $\\theta$ e l'intervallo di confidenza al 95%:\n\n\n\n\n::: {.cell layout-align=\"center\" vscode='{\"languageId\":\"r\"}'}\n\n```{.r .cell-code}\n# Extract posterior samples for parameter 'p'\nbayes_est <- fit_bernoulli$draws(variables = \"p\")\n\nbayes_est_p <- as.vector(bayes_est)\n\n# Calculate the mean of the Bayesian estimates for 'p'\nbayes_theta_est <- mean(bayes_est_p)\n\n# Calculate the 95% HDI using quantiles for the flattened vector\nhdi_bounds <- quantile(bayes_est_p, probs = c(0.025, 0.975))\n\n# Prepare the results with a single HDI for 'p'\nresults <- data.frame(\n    subj_num = 1,\n    n_items = n_items,\n    theta = theta,\n    bayes_theta = bayes_theta_est,\n    bayes_lo = hdi_bounds[1], # Lower bound of HDI\n    bayes_hi = hdi_bounds[2] # Upper bound of HDI\n)\n\n# Print the corrected results\nprint(results)\n#>      subj_num n_items theta bayes_theta bayes_lo bayes_hi\n#> 2.5%        1      30  0.63       0.651    0.484    0.797\n```\n:::\n\n\n\n\nAdesso svolgiamo la stessa simulazione considerando però 20 soggetti e facendo variare il numero di item del questionario (10, 30, 100).\n\n\n\n\n::: {.cell layout-align=\"center\" tags='hide-output' vscode='{\"languageId\":\"r\"}'}\n\n```{.r .cell-code}\nset.seed(43202)\n\nn_subj <- 20\nn_items_vec <- c(10, 30, 100)\n\n# Placeholder for results\nresults <- list()\n\nfor (n_items in n_items_vec) {\n    for (subj in 1:n_subj) {\n        # Generate \"true\" theta for the subject\n        theta <- rnorm(1, .7, .1)\n\n        # Generate observed data for the subject using \"true\" theta\n        Y <- rbinom(n_items, 1, prob = theta)\n\n        # Fit the model\n        fit_bernoulli <- mod$sample(\n            data = list(\n                N = 1,\n                N_items = n_items,\n                Y = matrix(Y, nrow = 1) # Ensure Y is a matrix\n            ),\n            iter_sampling = 2500,\n            iter_warmup = 500,\n            chains = 4,\n            parallel_chains = 4,\n            seed = 43202\n        )\n\n        # Extract and process posterior samples for 'p'\n        bayes_est_p <- as.vector(fit_bernoulli$draws(variables = \"p\"))\n        bayes_theta_est <- mean(bayes_est_p)\n        hdi_bounds <- quantile(bayes_est_p, probs = c(0.025, 0.975))\n\n        # Collect results\n        results[[paste(subj, n_items)]] <- data.frame(\n            subj_num = subj,\n            n_items = n_items,\n            theta = theta,\n            bayes_theta = bayes_theta_est,\n            bayes_lo = hdi_bounds[1],\n            bayes_hi = hdi_bounds[2]\n        )\n    }\n}\n```\n:::\n\n\n\n\nCombiniamo tutti i risultati in un singolo data frame.\n\n\n\n\n::: {.cell layout-align=\"center\" vscode='{\"languageId\":\"r\"}'}\n\n```{.r .cell-code}\nall_results <- bind_rows(results)\nall_results |> head()\n#>          subj_num n_items theta bayes_theta bayes_lo bayes_hi\n#> 2.5%...1        1      10 0.637       0.579    0.311    0.820\n#> 2.5%...2        2      10 0.722       0.653    0.379    0.875\n#> 2.5%...3        3      10 0.688       0.730    0.468    0.927\n#> 2.5%...4        4      10 0.554       0.653    0.385    0.879\n#> 2.5%...5        5      10 0.776       0.807    0.561    0.965\n#> 2.5%...6        6      10 0.695       0.731    0.470    0.924\n```\n:::\n\n\n\n\nCreiamo un grafico con i risultati ottenuti.\n\n\n\n\n::: {.cell layout-align=\"center\" vscode='{\"languageId\":\"r\"}'}\n\n```{.r .cell-code}\nggplot(all_results, aes(x = theta, y = bayes_theta)) +\n    geom_point() +\n    geom_errorbar(aes(ymin = bayes_lo, ymax = bayes_hi), width = 0.02) +\n    geom_hline(yintercept = 0.7, linetype = \"dashed\", color = \"gray\") + # Add dashed line at y = 0.7\n    # facet_wrap(~n_items, scales = \"free_x\", ncol = 1) + # Separate panels for each n_items, with a common y-axis\n    facet_wrap(c(\"n_items\"), nrow = 1) +\n    labs(x = \"True Theta\", y = \"Estimated p\") +\n    ggtitle(\"Estimated p vs. True Theta \\nfor Different Numbers of Items\") \n```\n\n::: {.cell-output-display}\n![](06_ctt_applications_files/figure-html/unnamed-chunk-13-1.png){fig-align='center' width=70%}\n:::\n:::\n\n\n\n\nLo scopo di questa simulazione è quello di confrontare i risultati del modello gerarchico bayesiano con i risultati ottenuti mediante la tecnica di Kelly. Per gli stessi dati utilizzati nel modello gerarchico bayesiamo, calcoliamo dunque la stima dei punteggi veri e gli intervalli di confidenza al 95% secondo il metodo di Kelley.\n\nLa formula di Kelley per stimare i punteggi veri dai punteggi osservati coinvolge l'affidabilità del test e la media e la deviazione standard dei punteggi osservati:\n\n$$ \n\\text{Punteggio Vero} = \\text{Media} + (\\text{Affidabilità}) \\times (\\text{Punteggio Osservato} - \\text{Media}).\n$$\n\nPer calcolare il CI al 95% per i punteggi veri, dobbiamo tener conto dell'errore standard di misurazione, che deriva dall'affidabilità del test:\n\n$$ \n\\text{SEM} = \\sigma \\times \\sqrt{1 - \\text{Affidabilità}},\n$$\n\ndove $ \\sigma $ è la deviazione standard dei punteggi osservati.\n\nDate la stima di SEM, l'intervallo di confidenza al 95% per il punteggio vero di un individuo può essere calcolato come segue:\n\n$$ \n\\text{CI} = \\text{Punteggio Vero} \\pm (1.96 \\times \\text{SEM}).\n$$\n\nSvolgiamo ora i calcoli in R.\n\n\n\n\n::: {.cell layout-align=\"center\" vscode='{\"languageId\":\"r\"}'}\n\n```{.r .cell-code}\n# Assuming a reliability coefficient\nr_xx <- 0.8\nZ_alpha <- qnorm(0.975) # For a 95% CI\n\n# Calculate estimated true scores and CIs\nall_results$kelley_true_score <- all_results$bayes_theta\nall_results$kelley_lo <- all_results$bayes_theta - (Z_alpha * sqrt(1 - r_xx) * sd(all_results$bayes_theta))\nall_results$kelley_hi <- all_results$bayes_theta + (Z_alpha * sqrt(1 - r_xx) * sd(all_results$bayes_theta))\n```\n:::\n\n\n\n\nA questo punto possiamo generare un grarico che contiene sia la stima del punteggio vero basata sul metodo di Kelley, insieme all'intervallo di confidenza al 95% (colore grigio), sia le stime bayesiane trovate in precedenza (colore blue).\n\nPer semplicità, ho solo considerato il caso in cui la stima di Kelley si riferisce al caso di 100 items.\n\n\n\n\n::: {.cell layout-align=\"center\" vscode='{\"languageId\":\"r\"}'}\n\n```{.r .cell-code}\nggplot() +\n    geom_point(data = all_results, aes(x = theta - 0.02, y = bayes_theta, color = \"Bayesian Estimate\")) +\n    geom_errorbar(data = all_results, aes(x = theta - 0.02, ymin = bayes_lo, ymax = bayes_hi, color = \"Bayesian Estimate\"), width = 0.02) +\n    geom_point(data = all_results, aes(x = theta, y = kelley_true_score, color = \"Kelley's Estimate\")) +\n    geom_errorbar(data = all_results, aes(x = theta, ymin = kelley_lo, ymax = kelley_hi, color = \"Kelley's Estimate\"), width = 0.02) +\n    geom_hline(yintercept = 0.7, linetype = \"dashed\", color = \"gray\") +\n    facet_wrap(c(\"n_items\"), nrow = 1) +\n    labs(x = \"True Theta\", y = \"Estimated Score\") +\n    ggtitle(\"Estimated Scores vs. True Theta\\nfor Different Numbers of Items\") +\n    scale_color_manual(values = c(\"Bayesian Estimate\" = \"blue\", \"Kelley's Estimate\" = \"darkgray\"))\n```\n\n::: {.cell-output-display}\n![](06_ctt_applications_files/figure-html/unnamed-chunk-15-1.png){fig-align='center' width=70%}\n:::\n:::\n\n\n\n\nI risultati della simulazione completa sono riportati nella figura seguente.\n\n::: {#fig-like}\n![](../../figures/haynes_kelley.png){width=\"80%\"}\nStime dei punteggi veri basate sul metodo della regressione di Kelley e sulla regressione gerarchica bayesiana.\n:::\n\nI risultati della simulazione indicano che le stime medie a posteriori del modello bayesiano, così come gli intervalli di credibilità al 95% (definiti come intervalli di densità di probabilità più elevata), mostrano una notevole congruenza con le stime corrispondenti dei punteggi veri ottenute mediante la regressione di Kelley, insieme ai relativi intervalli di confidenza al 95%. Le stime puntuali prodotte da entrambi i metodi risultano quasi sovrapponibili. Considerando che i punteggi veri derivanti dalla regressione di Kelley posseggono un'interpretazione bayesiana, la similitudine tra i risultati non dovrebbe sorprendere eccessivamente. Tuttavia, una conferma empirica di questa corrispondenza fornisce una validazione più robusta.\n\nQuesto esempio illustra come i modelli bayesiani gerarchici siano capaci di generare stime dei \"punteggi veri\" comparabili a quelle prodotte dalla teoria classica dei test, offrendo l'ulteriore vantaggio di non richiedere il calcolo dell'affidabilità per giungere a tali stime. Al contrario, l'approccio bayesiano si basa sull'adozione di assunzioni generative e distribuzionali riguardo le relazioni sia tra i parametri del modello a diversi livelli (ad esempio, la struttura gerarchica delinea le connessioni tra i parametri individuali e quelli di gruppo) sia con i dati osservati. In questo modo, adottando la media posteriore come stima dell'aspettativa dei parametri a livello individuale, siamo in grado di ottenere le stime più accurate dei parametri reali che sottendono la generazione dei dati osservati.\n\n## Riflessioni Conclusive\n\nIn questo capitolo, abbiamo analizzato diverse applicazioni pratiche della CTT. Ci siamo concentrati sulla comprensione dei concetti di attenuazione e sul metodo per determinare il numero di item necessari per ottenere un livello desiderato di affidabilità. Inoltre, abbiamo esaminato come stimare i punteggi veri individuali utilizzando due approcci differenti: la regressione di Kelley basata sulla CTT e la regressione gerarchica bayesiana. Approfondire questi argomenti ci ha permesso di ottenere una visione più completa e concreta sull'utilizzo e sull'applicazione della CTT, migliorando la nostra comprensione dei concetti chiave e delle implicazioni pratiche della teoria.\n\n## Session Info\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsessionInfo()\n#> R version 4.4.2 (2024-10-31)\n#> Platform: aarch64-apple-darwin20\n#> Running under: macOS Sequoia 15.3.1\n#> \n#> Matrix products: default\n#> BLAS:   /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRblas.0.dylib \n#> LAPACK: /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.0\n#> \n#> locale:\n#> [1] C/UTF-8/C/C/C/C\n#> \n#> time zone: Europe/Rome\n#> tzcode source: internal\n#> \n#> attached base packages:\n#> [1] parallel  stats     graphics  grDevices utils     datasets  methods  \n#> [8] base     \n#> \n#> other attached packages:\n#>  [1] doParallel_1.0.17  iterators_1.0.14   cmdstanr_0.8.1    \n#>  [4] truncnorm_1.0-9    ggridges_0.5.6     foreach_1.5.2     \n#>  [7] modelsummary_2.3.0 ggokabeito_0.1.0   see_0.10.0        \n#> [10] MASS_7.3-65        viridis_0.6.5      viridisLite_0.4.2 \n#> [13] ggpubr_0.6.0       ggExtra_0.10.1     gridExtra_2.3     \n#> [16] patchwork_1.3.0    bayesplot_1.11.1   semTools_0.5-6    \n#> [19] semPlot_1.1.6      lavaan_0.6-19      psych_2.4.12      \n#> [22] scales_1.3.0       markdown_1.13      knitr_1.49        \n#> [25] lubridate_1.9.4    forcats_1.0.0      stringr_1.5.1     \n#> [28] dplyr_1.1.4        purrr_1.0.4        readr_2.1.5       \n#> [31] tidyr_1.3.1        tibble_3.2.1       ggplot2_3.5.1     \n#> [34] tidyverse_2.0.0    here_1.0.1        \n#> \n#> loaded via a namespace (and not attached):\n#>   [1] tensorA_0.36.2.1     rstudioapi_0.17.1    jsonlite_1.9.1      \n#>   [4] magrittr_2.0.3       TH.data_1.1-3        estimability_1.5.1  \n#>   [7] farver_2.1.2         nloptr_2.1.1         rmarkdown_2.29      \n#>  [10] vctrs_0.6.5          minqa_1.2.8          base64enc_0.1-3     \n#>  [13] rstatix_0.7.2        htmltools_0.5.8.1    distributional_0.5.0\n#>  [16] broom_1.0.7          Formula_1.2-5        htmlwidgets_1.6.4   \n#>  [19] plyr_1.8.9           sandwich_3.1-1       emmeans_1.10.7      \n#>  [22] zoo_1.8-13           igraph_2.1.4         mime_0.12           \n#>  [25] lifecycle_1.0.4      pkgconfig_2.0.3      Matrix_1.7-2        \n#>  [28] R6_2.6.1             fastmap_1.2.0        rbibutils_2.3       \n#>  [31] shiny_1.10.0         digest_0.6.37        OpenMx_2.21.13      \n#>  [34] fdrtool_1.2.18       colorspace_2.1-1     ps_1.9.0            \n#>  [37] rprojroot_2.0.4      Hmisc_5.2-2          labeling_0.4.3      \n#>  [40] timechange_0.3.0     abind_1.4-8          compiler_4.4.2      \n#>  [43] withr_3.0.2          glasso_1.11          htmlTable_2.4.3     \n#>  [46] backports_1.5.0      carData_3.0-5        ggsignif_0.6.4      \n#>  [49] corpcor_1.6.10       gtools_3.9.5         tools_4.4.2         \n#>  [52] pbivnorm_0.6.0       foreign_0.8-88       zip_2.3.2           \n#>  [55] httpuv_1.6.15        nnet_7.3-20          glue_1.8.0          \n#>  [58] quadprog_1.5-8       nlme_3.1-167         promises_1.3.2      \n#>  [61] lisrelToR_0.3        grid_4.4.2           checkmate_2.3.2     \n#>  [64] cluster_2.1.8        reshape2_1.4.4       generics_0.1.3      \n#>  [67] gtable_0.3.6         tzdb_0.4.0           data.table_1.17.0   \n#>  [70] hms_1.1.3            car_3.1-3            tables_0.9.31       \n#>  [73] sem_3.1-16           pillar_1.10.1        rockchalk_1.8.157   \n#>  [76] posterior_1.6.1      later_1.4.1          splines_4.4.2       \n#>  [79] lattice_0.22-6       survival_3.8-3       kutils_1.73         \n#>  [82] tidyselect_1.2.1     miniUI_0.1.1.1       pbapply_1.7-2       \n#>  [85] reformulas_0.4.0     stats4_4.4.2         xfun_0.51           \n#>  [88] qgraph_1.9.8         arm_1.14-4           stringi_1.8.4       \n#>  [91] yaml_2.3.10          pacman_0.5.1         boot_1.3-31         \n#>  [94] evaluate_1.0.3       codetools_0.2-20     mi_1.1              \n#>  [97] cli_3.6.4            RcppParallel_5.1.10  rpart_4.1.24        \n#> [100] xtable_1.8-4         Rdpack_2.6.2         processx_3.8.6      \n#> [103] munsell_0.5.1        Rcpp_1.0.14          coda_0.19-4.1       \n#> [106] png_0.1-8            XML_3.99-0.18        jpeg_0.1-10         \n#> [109] lme4_1.1-36          mvtnorm_1.3-3        openxlsx_4.2.8      \n#> [112] rlang_1.1.5          multcomp_1.4-28      mnormt_2.1.1\n```\n:::\n",
    "supporting": [
      "06_ctt_applications_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}