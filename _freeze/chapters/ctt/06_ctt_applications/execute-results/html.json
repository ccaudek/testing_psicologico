{
  "hash": "71db5d53e2ebbd4fefb61d6ed860af73",
  "result": {
    "engine": "knitr",
    "markdown": "# Applicazioni della CTT {#sec-ctt-applications}\n\n**Preparazione del Notebook**\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhere::here(\"code\", \"_common.R\") |> source()\npacman::p_load(\n  lavaan, modelsummary, foreach, ggridges, truncnorm,\n  cmdstanr, doParallel\n)\n```\n:::\n\n\n\n\n## Introduzione\n\nIn questo capitolo vengono esplorate alcune tra le più importanti applicazioni della CTT, con particolare attenzione alle implicazioni operative che derivano dalla sua struttura teorica di base. Il percorso che seguiremo tocca diversi aspetti fondamentali:\n\n1. **Affidabilità e lunghezza del test.** Verrà mostrato come stimare il numero di item necessari per ottenere un certo livello di affidabilità, grazie all’impiego di formule specifiche (ad esempio, l’adattamento della formula di Spearman-Brown). Questo consente di progettare strumenti di misura calibrati sulle esigenze di precisione richieste.\n\n2. **Attenuazione della correlazione.** Illustreremo il fenomeno per cui l’errore di misurazione “nasconde” o riduce la vera correlazione tra due variabili, analizzando i metodi proposti per “disattenuare” tale correlazione (ad esempio, la formula di correzione in funzione dell’affidabilità).\n\n3. **Stima dei punteggi veri a livello individuale.** Saranno presentate le procedure per migliorare l’accuratezza dei punteggi osservati, in particolare mediante la regressione di Kelley, che permette di avvicinare i punteggi individuali alla media di gruppo in proporzione all’affidabilità del test. \n\n4. **Modelli gerarchici bayesiani.** Concluderemo evidenziando come l’approccio classico possa essere esteso o rivisto in un’ottica pienamente probabilistica attraverso modelli gerarchici bayesiani, che offrono una naturale interpretazione “shrinkante” degli stessi concetti, senza necessitare di un coefficiente di affidabilità calcolato a priori.\n\nNel complesso, lo scopo di questo capitolo è fornire una visione articolata su come la CTT, con i suoi strumenti e le sue formule, possa guidare non solo la costruzione e la valutazione di un test, ma anche l’interpretazione dei dati ottenuti. Al tempo stesso, il richiamo all’approccio bayesiano evidenzia come molte procedure classiche trovino un corrispettivo in modelli moderni, sottolineando la continuità tra i due paradigmi.\n\n## Stimare un Cambiamento Clinicamente Significativo\n\nUn tema fondamentale in psicologia clinica è stabilire se un individuo abbia effettivamente manifestato un **cambiamento clinicamente significativo** nel tempo. I metodi per valutarlo rientrano per lo più in due categorie: i metodi “basati su ancoraggi” e quelli “basati sulla distribuzione” [@blampied2022reliable].\n\n- **Metodi basati su ancoraggi.** Stabiliscono che un cambiamento clinicamente significativo debba corrispondere a un evento o a un segnale “clinicamente rilevante” esterno allo strumento di misura. In altre parole, invece di concentrarsi solo su quanti punti sono cambiati in una scala, questi metodi pongono l’accento sulla **qualità** di quel cambiamento: la variazione di punteggio deve essere associata a un miglioramento (o peggioramento) tangibile nello stato clinico del paziente, tale da essere riconosciuto come rilevante dal punto di vista clinico o terapeutico.\n\n    **Esempio pratico.**  \n    Supponiamo di valutare l’efficacia di una psicoterapia per la depressione. Un ricercatore vuole stabilire se i pazienti hanno ottenuto un “cambiamento clinicamente significativo” nel loro stato depressivo, misurato con un questionario standard (ad es. un punteggio su una scala da 0 a 60).\n  \n    1. **Definizione dell’ancoraggio clinico**  \n       Si sceglie come *ancora* il fatto che un paziente non soddisfi più i criteri clinici per la diagnosi di depressione secondo un colloquio diagnostico strutturato (es. MINI, SCID). Questo “evento” costituisce un passaggio riconosciuto come clinicamente rilevante.\n    \n    2. **Collegamento fra scala e ancoraggio**  \n       Il passo successivo è stabilire quale differenza di punteggio sul questionario corrisponda tipicamente a questa transizione “da depresso a non depresso”. Ad esempio, attraverso dati esistenti o nuove analisi, si individua che la maggior parte dei pazienti che escono dalla diagnosi presenta una riduzione di almeno 10 punti sulla scala.\n    \n    3. **Soglia di significatività**  \n       Il ricercatore definisce dunque come “clinicamente significativo” un miglioramento di 10 o più punti sul questionario, *purché* sia coerente con il superamento della soglia diagnostica. In questo modo, la variazione osservata non è solo una questione di numeri, bensì è “ancorata” a un cambiamento concreto: il passaggio effettivo dallo stato di diagnosi di depressione allo stato di remissione clinica.\n    \n    Grazie a questo collegamento, l’approccio basato su ancoraggi permette di interpretare la variazione dei punteggi alla luce di uno scenario clinico reale e tangibile.\n\n- **Metodi basati sulla distribuzione.** Utilizzano gli indici di errore di misurazione per stabilire se la variazione del punteggio sia sufficientemente grande da non poter essere spiegata dal solo errore. Uno dei primi e più noti metodi di questo tipo è il **Reliable Change Index** (RCI), introdotto da Jacobson e Truax. Alla base dell’RCI vi è l’errore standard della differenza (SED), a sua volta derivato dall’errore standard di misura (SEM). Come abbiamo discusso, quest’ultimo si ottiene dalla seguente formula:\n\n  $$\n  SEM = s_x \\sqrt{1 - r_{xx'}},\n  $$\n\n  dove $s_x$ è la deviazione standard dei punteggi al pre-test e $r_{xx'}$ l’affidabilità dello strumento. **Se la variazione osservata nel punteggio di un individuo supera l’errore di misurazione intrinseco**, si può concludere che il cambiamento sia **clinicamente significativo** e non soltanto frutto della variabilità casuale legata alla misura.\n\n### Calcolo del Reliable Change Index\n\nLa logica dell’RCI si basa su una suddivisione di qualunque punteggio osservato ($X$) in due componenti: il punteggio vero ($T$) e un errore di misurazione ($E$):\n\n$$\nX = T \\pm E.\n$$\n\nSe una persona subisce un vero cambiamento tra due tempi di osservazione ($t1$ e $t2$), ciò dovrebbe riflettersi in una differenza fra i relativi **punteggi veri**. Tuttavia, la presenza dell’errore di misurazione rende possibile osservare differenze anche in assenza di un mutamento reale. Di conseguenza, occorre stabilire *quanto* debba essere ampio un cambiamento per poterlo definire genuino e non dovuto a fluttuazioni casuali.\n\nJacobson e Truax (1991), riprendendo concetti introdotti da Jacobson e colleghi (1984), sfruttarono la distribuzione degli errori di misurazione (che ha media zero e varianza pari al $SEM^2$) per definire un indice che quantifica l’entità di un cambiamento in termini di **unità di errore standard**.\n\n### Calcolo della differenza tra punteggi e distribuzione di errore\n\nIl modo più diretto per rilevare un cambiamento consiste nel calcolare il **punteggio di differenza** (o *change score*) tra due tempi di misura:\n\n$$\nC_i = X_{t1} - X_{t2},\n$$ {#eq-change-score-def} \n\ndove $C_i$ rappresenta il cambiamento per l’individuo $i$. Poiché ogni punteggio osservato comprende una componente di errore, il punteggio di differenza conterrà anche l’errore combinato delle due misurazioni (si veda la discussione precedente sull'affidabilità dei punteggi differenza).\n\nLa distribuzione di questi *errori di differenza* ha anch’essa media zero, ma una deviazione standard **più grande**, chiamata **deviazione standard della differenza** ($SD_{Diff}$). Per due misure indipendenti o non correlate dal punto di vista dell’errore, essa è data da:\n\n$$\nSD_{Diff} = \\sqrt{2 \\cdot SEM^2}.\n$$ {#eq-sd-diff-def}\n\nQuesto nasce dalla proprietà secondo cui la varianza della differenza fra due variabili indipendenti si ottiene sommando le loro varianze. Anche se i punteggi veri al pre- e post- possono essere correlati (perché appartengono alla stessa persona), si assume in psicometria che gli *errori di misurazione* siano indipendenti fra loro.\n\n### Definizione dell’RCI\n\nUna volta calcolati il punteggio di differenza $C_i$ e la sua deviazione standard $SD_{Diff}$, l’RCI è semplicemente il **punteggio di differenza standardizzato**:\n\n$$\nC_i(\\text{Standardized}) = \\frac{C_i}{SD_{Diff}}.\n$$ {#eq-rci-def}\n\nAnalogamente a uno *z-score*, l’RCI indica di quante *unità di errore standard* differisce il cambiamento osservato dal valore zero (che corrisponderebbe a nessun cambiamento reale). Più alto è l’RCI in valore assoluto, più ci si può ragionevolmente aspettare che la variazione misurata rifletta un mutamento vero e non solo un artefatto della misura.  \n\nUn RCI che superi una determinata soglia (spesso ±1.96 per p < .05) suggerisce un cambiamento talmente ampio da poter essere considerato *clinicamente significativo*, cioè non spiegabile interamente dall’errore di misurazione.\n\n\n### Esempio in R\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Simulazione di dati psicologici\nset.seed(123) # Per replicabilità\ndati <- data.frame(\n  ID = 1:100, # 100 partecipanti\n  t1 = rnorm(100, mean = 25, sd = 5), # Punteggi al tempo 1\n  t2 = rnorm(100, mean = 23, sd = 5) # Punteggi al tempo 2\n)\n\n# Supponiamo che l'affidabilità del test sia nota\nreliability <- 0.85 # Esempio di coefficiente di affidabilità\nsd_test <- 5 # Deviazione standard della misura\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Calcolo dell'errore standard di misura (SEM)\nSEM <- sd_test * sqrt(1 - reliability)\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Calcolo della deviazione standard della differenza tra le due misure\nSD_Diff <- sqrt(2 * SEM^2)\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Calcolo del punteggio di differenza\ndati$Change_Score <- dati$t1 - dati$t2\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Calcolo dell'RCI per ciascun individuo\ndati$RCI <- dati$Change_Score / SD_Diff\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Identificare i cambiamenti clinicamente significativi (soglia ±1.96)\ndati$Significativo <- abs(dati$RCI) > 1.96\n\n# Mostrare i primi risultati\nhead(dati)\n#>   ID    t1    t2 Change_Score    RCI Significativo\n#> 1  1 22.20 19.45       2.7497  1.004         FALSE\n#> 2  2 23.85 24.28      -0.4353 -0.159         FALSE\n#> 3  3 32.79 21.77      11.0270  4.026          TRUE\n#> 4  4 25.35 21.26       4.0903  1.494         FALSE\n#> 5  5 25.65 18.24       7.4045  2.704          TRUE\n#> 6  6 33.58 22.77      10.8005  3.944          TRUE\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Visualizzazione dei RCI\nggplot(dati, aes(x = RCI)) +\n  geom_histogram(\n    binwidth = 0.5,\n    fill = \"blue\",\n    alpha = 0.5,\n    color = \"black\"\n  ) +\n  geom_vline(\n    xintercept = c(-1.96, 1.96),\n    linetype = \"dashed\",\n    color = \"red\"\n  ) +\n  labs(\n    title = \"Distribuzione dell'RCI\",\n    x = \"Reliable Change Index\",\n    y = \"Frequenza\"\n  )\n```\n\n::: {.cell-output-display}\n![](06_ctt_applications_files/figure-html/unnamed-chunk-8-1.png){fig-align='center' width=70%}\n:::\n:::\n\n\n\n\n## Affidabilità e Lunghezza del Test\n\nUn modo per determinare quanti item servano a raggiungere un dato livello di affidabilità è sfruttare la formula di **Spearman-Brown**, adattandola per calcolare la lunghezza del test desiderata. Nel caso di un *item medio* con affidabilità stimata $\\rho_1$ e di un test esteso il cui obiettivo è raggiungere l’affidabilità complessiva $\\rho_p$, la formula che restituisce il numero di item $p$ necessari è:\n\n$$\np = \\frac{\\rho_p (1 - \\rho_1)}{\\rho_1 (1 - \\rho_p)}.\n$$ {#eq-spearman-brown-number-items}\n\n### Esempio in R\n\nSupponiamo, per esempio, che un test composto da 5 item abbia un’affidabilità di 0.824 e che $\\rho_1$ (affidabilità dell’item medio) sia pari a 0.479. Se desideriamo raggiungere un’affidabilità complessiva $\\rho_p$ di 0.95, applicando l'@eq-spearman-brown-number-items si ottiene un valore di $p$ di circa 21 item. In altre parole, servirebbe un totale di 21 item per raggiungere una stima di affidabilità pari a 0.95.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Esempio di calcolo in R\nrho_1 <- 0.479\ndesired_rho <- 0.95\nn_items_needed <- (desired_rho * (1 - rho_1)) / (rho_1 * (1 - desired_rho))\nn_items_needed\n#> [1] 20.67\n```\n:::\n\n\n\n\n## Attenuazione\n\n### Attenuazione e Correlazioni Disattenuate\n\nUn fenomeno importante nell’analisi statistica è **l’attenuazione**, ovvero la riduzione della correlazione osservata fra due variabili dovuta alla presenza di errore di misurazione in una o entrambe le scale. Se l’errore di misurazione è elevato, la correlazione empirica tende a essere sottostimata rispetto a quella vera, dando luogo al cosiddetto *effetto di attenuazione*.\n\nCome discusso da @lord1968statistical, quando si creano scale di misura per rappresentare due costrutti e si vuole valutarne la relazione, l’errore incluso in ciascuna scala fa sì che la **correlazione osservata** sia inferiore alla **correlazione vera** fra i costrutti. Per stimare questa correlazione vera (o latente), si applicano formule di **correzione per l’attenuazione** che sfruttano i coefficienti di affidabilità delle due misure.\n\nSe $X$ e $Y$ sono i punteggi osservati e $T_X$ e $T_Y$ i punteggi veri di due costrutti, la **correlazione disattenuata** tra i punteggi veri si calcola come:\n\n$$\n\\rho(T_X, T_Y) = \\frac{\\rho_{XY}}{\\sqrt{\\rho_{XX^\\prime} \\,\\rho_{YY^\\prime}}},\n\\tag{2}\n$$\n\ndove $\\rho_{XY}$ è la correlazione osservata tra $X$ e $Y$, mentre $\\rho_{XX^\\prime}$ e $\\rho_{YY^\\prime}$ sono le affidabilità delle due scale.\n\nAllo stesso modo, se si desidera la correlazione tra i punteggi osservati di un test $X$ e i *punteggi veri* di un secondo test $T_Y$, la formula è:\n\n$$\n\\rho(X, T_Y) = \\frac{\\rho_{XY}}{\\sqrt{\\rho_{YY^\\prime}}}.\n\\tag{3}\n$$\n\nQueste formule, radicate nella Teoria Classica dei Test (CTT), permettono di “risalire” a quanto due costrutti latenti siano effettivamente correlati, depurando il contributo dell’errore di misurazione.\n\n\n::: {.callout-tip title=\"Dimostrazione\" collapse=\"true\"}\nPer dimostrare la formula della correlazione disattenuata, ci basiamo sulla **Teoria Classica dei Test (CTT)**, che postula che ogni punteggio osservato $X$ e $Y$ è la somma del rispettivo punteggio vero $T_X$ e $T_Y$ e di un errore casuale $E_X$ e $E_Y$:\n\n$$\nX = T_X + E_X ,\n$$\n$$\nY = T_Y + E_Y ,\n$$\n\ndove si assume che:\n\n1. $E_X$ e $E_Y$ siano indipendenti dai punteggi veri $T_X$ e $T_Y$;\n2. gli errori abbiano media zero e varianza finita;\n3. la correlazione tra i punteggi veri è quella che vogliamo stimare.\n\n\n**Passo 1: Definizione della Correlazione Osservata.**\n\nLa correlazione tra i punteggi osservati $X$ e $Y$ è:\n\n$$\n\\rho_{XY} = \\frac{\\text{Cov}(X, Y)}{\\sigma_X \\sigma_Y}.\n$$\n\nSostituendo $X = T_X + E_X$ e $Y = T_Y + E_Y$:\n\n$$\n\\text{Cov}(X, Y) = \\text{Cov}(T_X + E_X, T_Y + E_Y).\n$$\n\nEspandiamo la covarianza:\n\n$$\n\\text{Cov}(X, Y) = \\text{Cov}(T_X, T_Y) + \\text{Cov}(T_X, E_Y) + \\text{Cov}(E_X, T_Y) + \\text{Cov}(E_X, E_Y).\n$$\n\nPoiché gli errori sono indipendenti dai punteggi veri, le covarianze miste si annullano:\n\n$$\n\\text{Cov}(X, Y) = \\text{Cov}(T_X, T_Y).\n$$\n\nQuindi,\n\n$$\n\\rho_{XY} = \\frac{\\text{Cov}(T_X, T_Y)}{\\sigma_X \\sigma_Y}.\n$$\n\n\n**Passo 2: Relazione tra la Varianza Osservata e la Varianza Vera.**\n\nLa varianza dei punteggi osservati è:\n\n$$\n\\sigma_X^2 = \\sigma_{T_X}^2 + \\sigma_{E_X}^2.\n$$\n\nLa **affidabilità** $\\rho_{XX'}$ è definita come la proporzione della varianza del punteggio vero sulla varianza osservata:\n\n$$\n\\rho_{XX'} = \\frac{\\sigma_{T_X}^2}{\\sigma_X^2}.\n$$\n\nAnalogamente,\n\n$$\n\\rho_{YY'} = \\frac{\\sigma_{T_Y}^2}{\\sigma_Y^2}.\n$$\n\nDunque, la deviazione standard dei punteggi veri può essere scritta in funzione della deviazione standard osservata e dell’affidabilità:\n\n$$\n\\sigma_{T_X} = \\sigma_X \\sqrt{\\rho_{XX'}}, \\quad \\sigma_{T_Y} = \\sigma_Y \\sqrt{\\rho_{YY'}}.\n$$\n\n\n**Passo 3: Espressione della Correlazione Vera.**\n\nSostituendo nella formula della correlazione:\n\n$$\n\\rho_{T_X T_Y} = \\frac{\\text{Cov}(T_X, T_Y)}{\\sigma_{T_X} \\sigma_{T_Y}}.\n$$\n\nSostituendo la covarianza già calcolata:\n\n$$\n\\rho_{T_X T_Y} = \\frac{\\rho_{XY} \\sigma_X \\sigma_Y}{\\sigma_{T_X} \\sigma_{T_Y}}.\n$$\n\nOra sostituiamo $\\sigma_{T_X} = \\sigma_X \\sqrt{\\rho_{XX'}}$ e $\\sigma_{T_Y} = \\sigma_Y \\sqrt{\\rho_{YY'}}$:\n\n$$\n\\rho_{T_X T_Y} = \\frac{\\rho_{XY} \\sigma_X \\sigma_Y}{\\sigma_X \\sqrt{\\rho_{XX'}} \\cdot \\sigma_Y \\sqrt{\\rho_{YY'}}}.\n$$\n\nSemplificando,\n\n$$\n\\rho_{T_X T_Y} = \\frac{\\rho_{XY}}{\\sqrt{\\rho_{XX'} \\rho_{YY'}}}.\n$$\n\nQuesta è la formula della correlazione disattenuata.\n:::\n\n#### Intervalli di confidenza per la correlazione corretta\n\nIl calcolo degli intervalli di confidenza per la **correlazione disattenuata** richiede qualche cautela: un approccio comune è applicare la *formula di disattenuazione* agli estremi dell’intervallo di confidenza della correlazione osservata, consapevoli che tale procedura è approssimativa. In pratica, si stima l’intervallo di confidenza della correlazione osservata e se ne calcola una versione “corretta” sostituendo in formula i valori limite dell’intervallo.\n\nAd esempio, si consideri un caso in cui la correlazione osservata $\\rho_{XY} = 0.50$, con affidabilità $\\rho_{XX^\\prime} = 0.70$ e $\\rho_{YY^\\prime} = 0.80$. Applicando la formula $(2)$, la correlazione disattenuata è:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nr_osservata <- 0.5\nrho_X <- 0.7\nrho_Y <- 0.8\n\nr_corretta <- r_osservata / sqrt(rho_X * rho_Y)\nr_corretta\n#> [1] 0.6682\n```\n:::\n\n\n\n\nSe l’intervallo di confidenza della correlazione osservata andasse, ad esempio, da 0.40 a 0.60, si otterrebbero due estremi per la correlazione corretta applicando la stessa operazione:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nCI_lower_observed <- 0.4\nCI_upper_observed <- 0.6\n\nCI_lower_corrected <- CI_lower_observed / sqrt(rho_X * rho_Y)\nCI_upper_corrected <- CI_upper_observed / sqrt(rho_X * rho_Y)\n\ncat(\n  \"Intervallo di confidenza corretto: da\",\n  CI_lower_corrected, \"a\", CI_upper_corrected\n)\n#> Intervallo di confidenza corretto: da 0.5345 a 0.8018\n```\n:::\n\n\n\n\nÈ importante sottolineare che, sebbene questa procedura offra una stima veloce dei limiti di confidenza disattenuati, non costituisce un metodo pienamente rigoroso per calcolare l’incertezza attorno alle correlazioni latenti.\n\n#### Esempio classico di Spearman\n\nL’utilizzo delle correlazioni disattenuate risale a Spearman (1904), il quale evidenziò come la correlazione empirica tra una misura di **discriminazione dell’altezza del suono** ($X$) e **l’intelligenza valutata dall’insegnante** ($Y$) fosse pari a $\\hat{\\rho}_{XY} = 0.38$. Notando che le due misure avevano affidabilità basse ($\\hat{\\rho}_{XX'} = 0.25$ e $\\hat{\\rho}_{YY'} = 0.55$), Spearman corresse la correlazione per l’attenuazione, ottenendo addirittura un valore di poco superiore a 1. Questo esempio evidenzia un limite ben noto: la formula di disattenuazione, se applicata a stime di affidabilità troppo basse o a correlazioni molto elevate, può dare risultati paradossali (correlazioni > 1).\n\nGià all’epoca, ciò innescò un vivace dibattito con Pearson, il quale non accettò l’idea di “quantità non osservabili” e restò scettico verso una correlazione superiore a 1. Ciononostante, Spearman proseguì i suoi studi, contribuendo in maniera determinante allo sviluppo dell’**analisi fattoriale** e mostrando come spesso le correlazioni disattenuate si avvicinassero all’unità nel caso di variabili fortemente collegate allo stesso fenomeno.\n\nMcDonald (1999) sottolinea l’importanza di un uso cauto di queste correlazioni corrette, suggerendo che i modelli di **equazioni strutturali** (SEM) forniscono stime più robuste, in quanto permettono di modellare direttamente le variabili latenti senza dover ricorrere a correzioni ex post.\n\n## Usare l’Affidabilità per Migliorare l’Inferenza a Livello Individuale\n\nUn altro uso cruciale dell’affidabilità è il miglioramento delle stime dei **punteggi veri** di ciascun individuo, come abbiamo visto nel @sec-ctt-true-score-estimate.\n\n### Legami con gli stimatori di James-Stein, i Modelli Multilivello e l’Analisi Bayesiana\n\nLe equazioni di @kelley1921reliability anticipano di molti anni i principi alla base degli **stimatori di James-Stein**, che prevedono anch’essi un aggiustamento delle stime individuali verso la media del gruppo per ottenere stime più accurate. Questo principio trova un parallelo nei **modelli multilivello**, che trattano i punteggi individuali come derivanti da una distribuzione di gruppo, attenuando le stime soggettive sulla base dell’incertezza associata.\n\nIn un’ottica bayesiana, se si assume che i punteggi veri seguano una distribuzione *a priori* (ad esempio, una normale centrata sulla media del campione), la **media a posteriori** coincide con la stima di Kelley (de Gruijter & van der Kamp, 2008). Questo suggerisce un forte legame concettuale tra la psicometria classica e l’inferenza bayesiana, mostrando come l’informazione di gruppo possa migliorare la stima dei punteggi individuali.\n\nIn pratica, lo stesso principio viene sfruttato nei modelli multilivello, implementabili ad esempio con il pacchetto `lme4` in R o tramite modelli bayesiani gerarchici con `brms` o `rstanarm`. Questi approcci riducono l’errore di stima dei singoli soggetti integrando informazioni sull’intero gruppo, analogamente alla regressione di Kelley, ma con maggiore flessibilità e rigore probabilistico.\n\n### Simulazione: Stima dei Punteggi Veri con Pooling\n\nPer illustrare concretamente l’effetto del **pooling** verso la media, riportiamo un esempio in R, ispirato al codice di Nathaniel Haines. La simulazione genera dati per 20 soggetti con probabilità di successo media di 0.7, variando il numero di item (10, 30, 100) per osservare come cambia l’affidabilità (e di conseguenza la stima dei punteggi veri).\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nset.seed(43202)\n\n# Numero di soggetti e di item\nn_subj <- 20\nn_items <- c(10, 30, 100)\n\n# Campione casuale di punteggi veri intorno a 0.7\ntheta <- rnorm(n_subj, .7, .1)\n\n# Funzione per stimare l'errore standard di misura (al quadrato)\nest_se2 <- function(x) {\n  p <- mean(x)\n  q <- 1 - p\n  n <- length(x)\n  # Varianza dell'errore per item binari\n  sig2_ep_i <- (p * q) / (n - 1)\n  sig2_ep_i\n}\n\n# Simulazione\ndis_dat <- foreach(i = seq_along(n_items), .combine = \"rbind\") %do% {\n  # Genera dati osservati (binari) per ciascun soggetto\n  X_all <- foreach(t = seq_along(theta), .combine = \"rbind\") %do% {\n    rbinom(n_items[i], 1, prob = theta[t])\n  }\n  # Media di gruppo\n  X_bar <- mean(rowMeans(X_all))\n\n  # Calcolo dell'affidabilità\n  X <- rowMeans(X_all)\n  sig2_ep <- mean(apply(X_all, 1, est_se2))\n  sig2_X <- var(X)\n  rho <- 1 - (sig2_ep / sig2_X)\n\n  # Stima dei punteggi veri secondo la formula di Kelley\n  foreach(t = seq_along(theta), .combine = \"rbind\") %do% {\n    X_i <- mean(X_all[t, ])\n    data.frame(\n      subj_num = t,\n      n_items = n_items[i],\n      theta = theta[t],\n      rho = rho,\n      X = X_i,\n      se_obs = sd(X) * sqrt(1 - rho),\n      se_hat = sd(X) * sqrt(1 - rho) * sqrt(rho),\n      theta_hat = (1 - rho) * X_bar + rho * X_i\n    )\n  }\n}\n\n# Visualizzazione\ndis_dat %>%\n  mutate(subj_num = reorder(subj_num, theta)) %>%\n  ggplot(aes(x = subj_num, y = theta)) +\n  geom_point() +\n  geom_point(aes(y = X),\n    color = \"gray\",\n    position = position_jitter(width = .2, height = 0, seed = 1)\n  ) +\n  geom_linerange(\n    aes(ymin = X - 1.96 * se_obs, ymax = X + 1.96 * se_obs),\n    color = \"gray\",\n    position = position_jitter(width = .2, height = 0, seed = 1)\n  ) +\n  geom_point(aes(y = theta_hat),\n    color = \"red\",\n    position = position_jitter(width = .2, height = 0, seed = 2)\n  ) +\n  geom_linerange(\n    aes(ymin = theta_hat - 1.96 * se_hat, ymax = theta_hat + 1.96 * se_hat),\n    color = \"red\",\n    position = position_jitter(width = .2, height = 0, seed = 2)\n  ) +\n  geom_hline(yintercept = mean(dis_dat$X), linetype = 2, color = \"black\") +\n  facet_wrap(~n_items, nrow = 1) +\n  ggtitle(\"Stime del punteggio vero basate sulla regressione di Kelley\") +\n  xlab(\"Soggetto\") +\n  ylab(\"Valore\") +\n  theme_minimal(base_size = 14) +\n  theme(\n    panel.grid = element_blank(),\n    axis.text.x.bottom = element_blank()\n  )\n```\n\n::: {.cell-output-display}\n![](06_ctt_applications_files/figure-html/unnamed-chunk-12-1.png){fig-align='center' width=70%}\n:::\n:::\n\n\n\n\n\nTre aspetti principali emergono da questo esempio:\n\n1. Le **stime puntuali** ottenute tramite la formula di Kelley ($\\hat{T}$) si trovano sempre *più vicine alla media del gruppo* rispetto ai punteggi osservati.\n2. L’effetto di **pooling** è tanto più marcato quanto più bassa è l’affidabilità. Nel codice, la manipolazione dell’affidabilità avviene variando il numero di item.\n3. Gli **intervalli di confidenza** attorno a $\\hat{T}$ risultano *più stretti* rispetto agli IC dei punteggi osservati, confermando come la stima di Kelley riduca l’incertezza legata all’errore di misurazione.\n\nQuesta simulazione evidenzia la stretta relazione tra la **regressione di Kelley** e i **modelli bayesiani gerarchici**. Infatti, la regressione di Kelley corrisponde alla media a posteriori di un modello bayesiano gerarchico normale con priori non informativi. In un modello multilivello bayesiano, i punteggi veri sono stimati utilizzando una distribuzione di gruppo, proprio come nella psicometria classica, ma con il vantaggio di una gestione probabilistica più raffinata e di intervalli di credibilità per le stime individuali.\n\nIn sintesi, l’approccio di Kelley trova una corrispondenza diretta nei moderni metodi bayesiani e multilivello, poiché tutti questi approcci condividono il principio della **regressione verso la media** per contrastare l’errore di misurazione. La differenza principale è che, nell’approccio bayesiano, la stima dell’errore di misurazione e la correzione verso la media avvengono in modo integrato, senza la necessità di calcolare separatamente un coefficiente di affidabilità. Questo rende il metodo bayesiano più generale e flessibile, consentendo l’applicazione a scenari più complessi e la possibilità di incorporare informazioni a priori nelle stime.\n\n## Riflessioni Conclusive\n\nIn questo capitolo, abbiamo approfondito le principali applicazioni della Teoria Classica dei Test (CTT), analizzando sia gli aspetti teorici sia le implicazioni pratiche nella misurazione psicologica. In particolare, abbiamo:\n\n- **Esaminato il problema dell’attenuazione**, dimostrando come l’errore di misurazione possa ridurre artificialmente la correlazione tra costrutti psicologici e influenzare l’interpretazione dei risultati.\n- **Analizzato la formula di Spearman-Brown**, strumento essenziale per stimare il numero di item necessario a garantire un livello desiderato di affidabilità, mettendo in evidenza il ruolo strategico della progettazione dei test.\n- **Confrontato diversi metodi per stimare i punteggi veri individuali**, includendo la regressione di Kelley, radicata nei principi della CTT, e l’approccio bayesiano gerarchico, che estende questi concetti in un quadro probabilistico più generale.\n\nLa CTT rappresenta una base essenziale per la costruzione e valutazione dei test psicometrici, fornendo strumenti chiari e affidabili per la progettazione e l’interpretazione dei risultati. Tuttavia, il parallelo con i modelli bayesiani e multilivello suggerisce che molti principi classici—come la regressione verso la media e la correzione dell’errore di misurazione—trovano una naturale estensione in approcci più avanzati, capaci di integrare l’incertezza e sfruttare al meglio l’informazione disponibile.\n\nLa comprensione di questi concetti è fondamentale per:\n\n1. **Progettare strumenti di misura** con un livello di affidabilità adeguato agli obiettivi della ricerca o della pratica psicologica.\n2. **Evitare distorsioni nelle stime** delle relazioni tra variabili, grazie a una corretta gestione dell’errore di misurazione e delle procedure di attenuazione.\n3. **Migliorare l’inferenza sui punteggi veri**, adottando approcci statistici appropriati che bilancino precisione e robustezza.\n\nLa CTT, pur rimanendo un fondamento imprescindibile per la psicometria, si integra oggi con metodologie più sofisticate—come la Teoria della Risposta all’Item (IRT) e i modelli di equazioni strutturali—che permettono di migliorare ulteriormente la qualità e la flessibilità delle misurazioni. L’evoluzione verso strumenti più avanzati consente di affinare la precisione delle valutazioni, con benefici concreti sia nella ricerca che nelle applicazioni cliniche e diagnostiche.\n\n\n## Session Info\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsessionInfo()\n#> R version 4.4.2 (2024-10-31)\n#> Platform: aarch64-apple-darwin20\n#> Running under: macOS Sequoia 15.3.2\n#> \n#> Matrix products: default\n#> BLAS:   /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRblas.0.dylib \n#> LAPACK: /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.0\n#> \n#> locale:\n#> [1] C/UTF-8/C/C/C/C\n#> \n#> time zone: Europe/Rome\n#> tzcode source: internal\n#> \n#> attached base packages:\n#> [1] parallel  stats     graphics  grDevices utils     datasets  methods  \n#> [8] base     \n#> \n#> other attached packages:\n#>  [1] doParallel_1.0.17  iterators_1.0.14   cmdstanr_0.8.1    \n#>  [4] truncnorm_1.0-9    ggridges_0.5.6     foreach_1.5.2     \n#>  [7] modelsummary_2.3.0 ggokabeito_0.1.0   see_0.11.0        \n#> [10] MASS_7.3-65        viridis_0.6.5      viridisLite_0.4.2 \n#> [13] ggpubr_0.6.0       ggExtra_0.10.1     gridExtra_2.3     \n#> [16] patchwork_1.3.0    bayesplot_1.11.1   semTools_0.5-6    \n#> [19] semPlot_1.1.6      lavaan_0.6-19      psych_2.4.12      \n#> [22] scales_1.3.0       markdown_1.13      knitr_1.50        \n#> [25] lubridate_1.9.4    forcats_1.0.0      stringr_1.5.1     \n#> [28] dplyr_1.1.4        purrr_1.0.4        readr_2.1.5       \n#> [31] tidyr_1.3.1        tibble_3.2.1       ggplot2_3.5.1     \n#> [34] tidyverse_2.0.0    here_1.0.1        \n#> \n#> loaded via a namespace (and not attached):\n#>   [1] tensorA_0.36.2.1     rstudioapi_0.17.1    jsonlite_1.9.1      \n#>   [4] magrittr_2.0.3       TH.data_1.1-3        estimability_1.5.1  \n#>   [7] farver_2.1.2         nloptr_2.2.1         rmarkdown_2.29      \n#>  [10] vctrs_0.6.5          minqa_1.2.8          base64enc_0.1-3     \n#>  [13] rstatix_0.7.2        htmltools_0.5.8.1    distributional_0.5.0\n#>  [16] broom_1.0.7          Formula_1.2-5        htmlwidgets_1.6.4   \n#>  [19] plyr_1.8.9           sandwich_3.1-1       emmeans_1.10.7      \n#>  [22] zoo_1.8-13           igraph_2.1.4         mime_0.13           \n#>  [25] lifecycle_1.0.4      pkgconfig_2.0.3      Matrix_1.7-3        \n#>  [28] R6_2.6.1             fastmap_1.2.0        rbibutils_2.3       \n#>  [31] shiny_1.10.0         digest_0.6.37        OpenMx_2.21.13      \n#>  [34] fdrtool_1.2.18       colorspace_2.1-1     ps_1.9.0            \n#>  [37] rprojroot_2.0.4      Hmisc_5.2-3          labeling_0.4.3      \n#>  [40] timechange_0.3.0     abind_1.4-8          compiler_4.4.2      \n#>  [43] withr_3.0.2          glasso_1.11          htmlTable_2.4.3     \n#>  [46] backports_1.5.0      carData_3.0-5        ggsignif_0.6.4      \n#>  [49] corpcor_1.6.10       gtools_3.9.5         tools_4.4.2         \n#>  [52] pbivnorm_0.6.0       foreign_0.8-88       zip_2.3.2           \n#>  [55] httpuv_1.6.15        nnet_7.3-20          glue_1.8.0          \n#>  [58] quadprog_1.5-8       nlme_3.1-167         promises_1.3.2      \n#>  [61] lisrelToR_0.3        grid_4.4.2           checkmate_2.3.2     \n#>  [64] cluster_2.1.8.1      reshape2_1.4.4       generics_0.1.3      \n#>  [67] gtable_0.3.6         tzdb_0.5.0           data.table_1.17.0   \n#>  [70] hms_1.1.3            car_3.1-3            tables_0.9.31       \n#>  [73] sem_3.1-16           pillar_1.10.1        rockchalk_1.8.157   \n#>  [76] posterior_1.6.1      later_1.4.1          splines_4.4.2       \n#>  [79] lattice_0.22-6       survival_3.8-3       kutils_1.73         \n#>  [82] tidyselect_1.2.1     miniUI_0.1.1.1       pbapply_1.7-2       \n#>  [85] reformulas_0.4.0     stats4_4.4.2         xfun_0.51           \n#>  [88] qgraph_1.9.8         arm_1.14-4           stringi_1.8.4       \n#>  [91] pacman_0.5.1         boot_1.3-31          evaluate_1.0.3      \n#>  [94] codetools_0.2-20     mi_1.1               cli_3.6.4           \n#>  [97] RcppParallel_5.1.10  rpart_4.1.24         xtable_1.8-4        \n#> [100] Rdpack_2.6.3         processx_3.8.6       munsell_0.5.1       \n#> [103] Rcpp_1.0.14          coda_0.19-4.1        png_0.1-8           \n#> [106] XML_3.99-0.18        jpeg_0.1-10          lme4_1.1-36         \n#> [109] mvtnorm_1.3-3        openxlsx_4.2.8       rlang_1.1.5         \n#> [112] multcomp_1.4-28      mnormt_2.1.1\n```\n:::\n",
    "supporting": [
      "06_ctt_applications_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}